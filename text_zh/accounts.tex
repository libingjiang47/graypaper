\section{服务账户}\label{sec:accounts}

正如我们之前所指出的，\Jam 中的服务在某种程度上类似于以太坊中的智能合约，它包含代码组件、存储组件以及余额等元素。但与以太坊不同，代码被拆分为两个相互隔离的入口点，每个入口点都具有各自的环境条件：其一是 \emph{Refinement}（精炼），本质上是无状态的，并在内核中执行；其二是 \emph{Accumulation}（累积），是有状态的，并在链上执行。接下来我们将重点讨论后者。

服务账户保存在状态中的 $\accounts$ 之下，它是从服务标识符 $\serviceid$ 到一组具名元素元组的部分映射，这些元素指定了与 \Jam 协议相关的服务属性。形式化定义如下：
\begin{align}\label{eq:serviceaccounts}
  \serviceid &\equiv \Nbits{32} \\
  \accounts &\in \dictionary{\serviceid}{\serviceaccount}
\end{align}

服务账户被定义为如下元组：存储字典 $\sa¬storage$，原像查询字典 $\sa¬preimages$ 与 $\sa¬requests$，代码哈希 $\sa¬codehash$，余额 $\sa¬balance$，以及免费存储偏移量 $\sa¬gratis$。此外还有两个代码 gas 限制：$\sa¬minaccgas$ 与 $\sa¬minmemogas$。我们还记录了与该账户相关的某些使用特征：创建时的时间槽 $\sa¬created$，最近一次累积的时间槽 $\sa¬lastacc$，以及父服务 $\sa¬parent$。形式化定义如下：
\begin{align}\label{eq:serviceaccount}
  \serviceaccount \equiv \tuple{\ \begin{aligned}
    \sa¬storage &\in \dictionary{\blob}{\blob}\,,\
    \sa¬preimages \in \dictionary{\hash}{\blob}\,,\\
    \sa¬requests &\in \dictionary{\tuple{\hash,\bloblength}}{\sequence[:3]{\timeslot}}\,,\\
    \sa¬gratis &\in \balance\,,\
    \sa¬codehash \in \hash\,,\
    \sa¬balance \in \balance\,,\
    \sa¬minaccgas \in \gas\,,\\
    \sa¬minmemogas &\in \gas\,,\
    \sa¬created \in \timeslot\,,\
    \sa¬lastacc \in \timeslot\,,\
    \sa¬parent \in \serviceid\\
    %i, o, f
  \end{aligned}\,}
\end{align}

因此，索引为 $s$ 的服务的余额记作 $\accounts\subb{s}_\sa¬balance$，而该服务键为 $\mathbf{k} \in \blob$ 的存储项则写作 $\accounts\subb{s}_\sa¬storage\subb{\mathbf{k}}$。


\subsection{代码与 Gas}

服务账户的代码及相关元数据通过一个哈希来标识。若该服务要具备功能，该哈希必须存在于其原像查询（见 \ref{sec:lookups} 节），并且该哈希的原像必须是由两个 blob 正确编码而成。于是我们定义实际代码 $\sa¬code$ 与元数据 $\sa¬metadata$：
\begin{align}
  \forall \mathbf{a} \in \serviceaccount : \tup{\mathbf{a}_\sa¬metadata, \mathbf{a}_\sa¬code} \equiv \begin{cases}
    \tup{\mathbf{m}, \mathbf{c}} &\when \encode{\var{\mathbf{m}}, \mathbf{c}} = \mathbf{a}_\sa¬preimages[\mathbf{a}_\sa¬codehash] \\
    \tup{\none, \none} &\otherwise
  \end{cases}
\end{align}

代码中存在两个入口点：
\begin{description}
  \item[0 \texttt{refine}] 精炼，在内核中执行并且是无状态的。\footnote{严格来说，这里假设了少量状态，即每个服务的原像最近实例。细节将在 \ref{sec:packagesanditems} 节中讨论。}
  \item[1 \texttt{accumulate}] 累积，在链上执行并且是有状态的。
\end{description}

精炼与累积将在 \ref{sec:computeworkreport} 节与 \ref{sec:accumulationexecution} 节中分别进行更详细的描述。

如附录 \ref{sec:virtualmachine} 所述，\Jam 虚拟机中的执行时间以 \emph{gas} 为单位确定性地度量，表示为小于 $2^{64}$ 的自然数，形式上记作 $\gas$。若该数值可能为负，则我们记作 $\signedgas$，即集合 $\Z_{-2^{63}\dots2^{63}}$。账户中规定了两个限制，它们决定了执行服务代码 \emph{Accumulate} 入口点所需的最小 gas。$\sa¬minaccgas$ 是每个工作项所需的最小 gas，而 $\sa¬minmemogas$ 是每次延迟转账所需的最小 gas。


\subsection{原像查询}\label{sec:lookups}

除了在链上存储任意键/值对外，账户还可以请求数据使其在内核中可用，从而可被服务代码的 Refine 逻辑访问。关于这一功能的状态保存在服务的 $\sa¬preimages$ 与 $\sa¬requests$ 组件之下。

原像查询与一般存储有几个不同点。首先，原像查询是哈希到原像的映射，而存储是任意键到值的映射。其次，原像数据是外部提供的，而存储数据是服务累积的一部分。第三，原像数据一旦提供，不能被随意移除；相反，它必须先被标记为不可用，经过一段时间后才能从状态中删除。这确保了其存在的历史信息会被保留。这一点尤其重要，因为原像数据的设计初衷是在内核中、服务代码的 Refine 逻辑下被查询，因此需要确保其历史可用性。

接下来我们重新表述与数据查询系统相关的状态部分。该系统的目的是在链上存储静态数据，以便稍后在任何服务代码的执行过程中，通过仅依赖数据哈希及其字节长度的函数来访问。

在 \emph{Accumulate} 的链上执行过程中，这一点是显然可行的，因为所有验证者在验证区块时天然共享完整状态，即 $\thestate$。然而，对于 \emph{Refine} 的内核执行，验证者之间并无天然共享状态；因此我们定义一个历史状态，称为 \emph{lookup anchor}（查询锚点），其必须被认为是最近已最终确定的，这样工作结果才能被累积，从而提供可用性保证。

通过保留其可用性的历史信息，我们可以确信任何拥有最近最终化视图的验证者都能够判断某个给定原像在可审计期间是否可用。这确保了即便没有链上状态共识，判断结果也将是确定性的。

换句话说，我们必须能够定义一个 \emph{历史} 查询函数 $\histlookup$，用来确定某个哈希的原像是否在某个时间槽可被某个服务账户查询，并在可用时提供该原像：
\begin{equation}
\begin{aligned}
  \histlookup\colon \abracegroup[\ ]{
    \tuple{\serviceaccount, \Nmax{(\H_\¬timeslot - \Cexpungeperiod) \dots \H_\¬timeslot}, \hash} &\to \optional{\blob} \\
    (\mathbf{a}, t, \blake{\mathbf{p}}) &\mapsto v : v \in \set{ \mathbf{p}, \none }
  }
\end{aligned}
\end{equation}

该函数将在下文的公式 \ref{eq:historicallookup} 中给出定义。

索引为 $s$ 的某个服务的原像查询记作 $\accounts\subb{s}_\sa¬preimages$，它是一个字典，将哈希映射到其对应的原像。此外，与查询相关的元数据记作 $\accounts\subb{s}_\sa¬requests$，它是一个字典，将某个哈希及预期长度映射到历史信息。


\subsubsection{不变式}

查询系统的状态自然满足若干不变式。首先，任何原像值必须对应其哈希，见公式 \ref{eq:preimageconstraints}。其次，原像值在状态中的存在意味着其哈希与长度对具有某种关联状态，同样见公式 \ref{eq:preimageconstraints}。形式化为：
\begin{equation}\label{eq:preimageconstraints}
  \forall \mathbf{a} \in \serviceaccount, \kv{h}{\mathbf{d}} \in \mathbf{a}_\sa¬preimages \Rightarrow
    h = \blake{\mathbf{d}}\wedge
    \tup{h , \len{\mathbf{d}}} \in \keys{\mathbf{a}_\sa¬requests}
\end{equation}


\subsubsection{语义}

历史状态组件 $h \in \sequence[:3]{\timeslot}$ 是一个最多包含三个时间槽的序列，其基数对应四种模式：
\begin{itemize}
  \item{$h = \sequence{}$}: 原像已被 \emph{请求}，但尚未提供。
  \item{$h \in \sequence[1]{\timeslot}$}: 原像已 \emph{可用}，并自时间 $h_0$ 起存在。
  \item{$h \in \sequence[2]{\timeslot}$}: 原先可用的原像自时间 $h_1$ 起已变为 \emph{不可用}，此前自时间 $h_0$ 起可用。
  \item{$h \in \sequence[3]{\timeslot}$}: 原像当前 \emph{可用}，并自时间 $h_2$ 起存在，此前在 $h_0$ 至 $h_1$ 时间段内也曾可用。
\end{itemize}

于是历史查询函数 $\histlookup$ 定义如下：
\begin{equation}
  \begin{aligned}\label{eq:historicallookup}
    &\histlookup\colon \tuple{\serviceaccount, \timeslot, \hash} \to \optional{\blob} \\
    &\histlookup(\mathbf{a}, t, h) \equiv \begin{cases}
      \mathbf{a}_\sa¬preimages\subb{h}\!\!\!\! &\when h \in \keys{\mathbf{a}_\sa¬preimages} \wedge I(\mathbf{a}_\sa¬requests\subb{h, \len{\mathbf{a}_\sa¬preimages\subb{h}}}, t) \!\!\!\!\! \\
      \none &\otherwise
    \end{cases}\\
    &\where I(\mathbf{l}, t) = \begin{cases}
      \bot &\when \sq{} = \mathbf{l} \\
      x \le t &\when \sq{x} = \mathbf{l} \\
      x \le t < y &\when \sq{x, y} = \mathbf{l} \\
      x \le t < y \vee z \le t &\when \sq{x, y, z} = \mathbf{l} \\
    \end{cases}
  \end{aligned}
\end{equation}


\subsection{账户占用与阈值余额}

我们定义依赖值 $\sa¬items$ 与 $\sa¬octets$ 为服务的存储占用量，分别表示存储中的项目数量与字节总数。它们仅由服务的存储映射决定，且必须假设每当服务存储被更改时，它们也相应变化。

此外，如 \ref{sec:serialization} 节中的账户序列化函数所示，这些数值预计会明确存在于默克尔化的状态数据中。基于此，我们显式定义它们的集合。

接着我们定义第三个依赖项 $\sa¬minbalance$，即给定服务账户所需的最小（或称 \emph{阈值}）余额，以其存储占用为依据。
\begin{align}
  \forall \mathbf{a} \in \values{\accounts}\colon \abracegroup{
    \mathbf{a}_\sa¬items \in \Nbits{32} &\equiv
      2\cdot\len{\,\mathbf{a}_\sa¬requests\,} + \len{\,\mathbf{a}_\sa¬storage\,} \\
    \mathbf{a}_\sa¬octets \in \Nbits{64} &\equiv
      \sum\limits_{\,\tup{h, z} \in \keys{\mathbf{a}_\sa¬requests}\,} \!\!\!\!81 + z \\
    &\phantom{\equiv\ } + \sum\limits_{\tup{x, y} \in \mathbf{a}_\sa¬storage} 34 + \len{y} + \len{x} \\
    \label{eq:deposits}
    \mathbf{a}_\sa¬minbalance \in \balance &\equiv
      \max(0,
        \Cbasedeposit
        + \Citemdeposit \cdot \mathbf{a}_\sa¬items
        + \Cbytedeposit \cdot \mathbf{a}_\sa¬octets
        - \mathbf{a}_\sa¬gratis
      )
  }
\end{align}


\subsection{服务权限}

\Jam 支持为若干服务授予权限。保存这些权限的状态部分记作 $\privileges$，其中包含五类权限。第一类是 $\manager$，即 \emph{管理者} 服务的索引，它能够在区块间修改 $\privileges$，并为服务授予存储抵押额度。第二类是 $\delegator$，它能够设置 $\stagingset$。接着，只有 $\registrar$ 能够创建受保护范围内索引的新服务账户。第四类是 $\assigners$，它们是能够修改授权队列 $\authqueue$ 的服务索引，每个核心对应一个。 

最后，$\alwaysaccers$ 是一个小字典，包含在每个区块中自动累积的服务索引，以及它们各自累积时所用的基本 gas 数量。形式化定义如下：
\begin{align}
  \label{eq:privilegesspec}
  \privileges &\equiv \tuple{
    \manager,
    \delegator,
    \registrar,
    \assigners,
    \alwaysaccers
  }\\
  \manager &\in \serviceid \ ,\qquad
  \delegator \in \serviceid \ ,\qquad
  \registrar \in \serviceid \\
  \assigners &\in \sequence[\Ccorecount]{\serviceid} \ ,\qquad
  \alwaysaccers \in \dictionary{\serviceid}{\gas}
\end{align}
