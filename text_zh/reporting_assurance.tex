\section{Reporting and Assurance}
\label{sec:reporting}

“报告（reporting）”与“保障（assurance）”是两类链上流程，用来将内核（in-core）计算的结果写入到服务账户（$\accounts$）的状态中。一个由若干\emph{工作项（work-items）}构成的\emph{工作包（work-package）}，会被作为\emph{担保人（guarantors）}的验证者转化为相应的\emph{工作报告（work-report）}（同样由若干\emph{工作摘要（work-digests）}组成），并通过\emph{guarantees} 外部事务在链上提交。至此，工作包会被进行纠删码处理为大量片段（segments），每个片段被分发给关联的验证者，后者再通过在链上提交\emph{保障（assurance）}来证明其可用性。当积累到足够多的保障时，工作报告被视为\emph{可用（available）}，随后这些工作摘要会通过累积（accumulation）过程改变其关联服务的状态（见第 \ref{sec:accumulation} 节）。报告也可能被\emph{超时（timed-out）}，表示它可以在未进行累积的情况下被其他报告替换。

因此，从工作报告本身的视角看，先有“担保”再有“保障”。然而，从区块状态转换的视角看，最好先处理“保障”，因为每个核心（core）在同一时间最多只能有一个等待其包变为可用的工作报告。因此，下面我们先覆盖由处理可用性保障引起的转换，然后再处理工作报告的担保。通过需要一个中间状态 $\reportspostguarantees$（在式 \ref{eq:reportcoresareunusedortimedout} 后续使用）即可形式化地体现这种同步性。



\subsection{State}
协议中关于报告与可用性这部分的状态主要保存在 $\reports$ 中；它跟踪已经上报但尚未被超级多数验证者确认可用的工作报告，以及每个报告上报的时间。如前所述，任一时刻每个核心上最多只能分配一个报告。形式化地：
\begin{equation}
  \label{eq:reportingstate}
  \reports \in \sequence[\Ccorecount]{
    \optional{\tuple{
      \isa{\rs¬workreport}{\workreport} ,\,
      \isa{\rs¬timestamp}{\timeslot}
    }}
  }
\end{equation}

与往常一样，中间值与后验值（$\reportspostjudgement$、$\reportspostguarantees$、$\reportspostassurances$）与先验值具有相同的约束。

\subsubsection{Work Report}
\label{sec:workreport}
工作报告（集合 $\workreport$ 的元素）定义为一个元组：包含工作包规范 $\wr¬avspec$、细化（refinement）上下文 $\wr¬context$、核心索引（即在哪个核心上完成工作）$\wr¬core$，以及授权者哈希 $\wr¬authorizer$ 与授权轨迹 $\wr¬authtrace$；一个片段根查找字典 $\wr¬srlookup$；Is-Authorized 调用消耗的 gas（$\wr¬authgasused$）；最后是工作摘要 $\wr¬digests$，它由对包中各个条目求值的结果及相关数据组成。形式化地：
\begin{equation}
  \label{eq:workreport}
  \workreport \equiv \tuple{
    \begin{aligned}
      &\isa{\wr¬avspec}{\avspec},\ 
      \isa{\wr¬context}{\workcontext},\ 
      \isa{\wr¬core}{\coreindex},\ 
      \isa{\wr¬authorizer}{\hash},\ 
      \isa{\wr¬authtrace}{\blob},\\
      &\isa{\wr¬srlookup}{\dictionary{\hash}{\hash}},\ 
      \isa{\wr¬digests}{\sequence[1:\Cmaxpackageitems]{\workdigest}},\ 
      \isa{\wr¬authgasused}{\gas}
    \end{aligned}
  }
\end{equation}

我们将“片段根查找字典”中的条目数与“先决条件”的数量之和限制为 $\Cmaxreportdeps = 8$：
\begin{equation}
  \label{eq:limitreportdeps}
  \forall \wrX \in \workreport : \len{\wrX_\wr¬srlookup} + \len{(\wrX_\wr¬context)_\wc¬prerequisites} \le \Cmaxreportdeps
\end{equation}

\subsubsection{Refinement Context}

\emph{细化上下文（refinement context）}，记为集合 $\workcontext$，描述了报告对应工作包被求值时链的上下文。它标识两个历史区块：\emph{锚点（anchor）}，即区块头哈希 $\wc¬anchorhash$，以及其对应的后验状态根 $\wc¬anchorpoststate$ 和累积输出日志的超级峰值（super-peak）$\wc¬anchoraccoutlog$；以及\emph{查找锚点（lookup-anchor）}，即区块头哈希 $\wc¬lookupanchorhash$ 及其时间槽 $\wc¬lookupanchortime$。最后，它还标识任何先决工作包的哈希 $\wc¬prerequisites$。形式化地：
\begin{equation}
  \label{eq:workcontext}
  \workcontext \equiv \tuple{\,\begin{alignedat}{5}
    \isa{\wc¬anchorhash&}{\hash}\,,\;
    \isa{&\wc¬anchorpoststate&}{\hash}\,,\;
    \isa{&\wc¬anchoraccoutlog&}{\hash}\,,\;\\
    \isa{\wc¬lookupanchorhash&}{\hash}\,,\;
    \isa{&\wc¬lookupanchortime&}{\timeslot}\,,\;
    \isa{&\wc¬prerequisites&}{\protoset{\hash}}
  \end{alignedat}}
\end{equation}

\subsubsection{Availability}
我们将\emph{可用性规范（availability specifications）}集合 $\avspec$ 定义为一个元组：包含工作包哈希 $\as¬packagehash$、可审计的工作束长度 $\as¬bundlelen$（关于其含义见第 \ref{sec:availabiltyspecifier} 节），以及纠删根 $\as¬erasureroot$、片段根 $\as¬segroot$ 与片段计数 $\as¬segcount$。工作结果包含该可用性规范，以确保它们能够正确重建并审计任何上报工作包的影响，并为后续工作包在需要检索前序数据时提供依据。形式化地：
\begin{align}
  \label{eq:avspec}
  \avspec &\equiv \tuple{
    \isa{\as¬packagehash}{\hash}\,,\;
    \isa{\as¬bundlelen}{\bloblength}\,,\;
    \isa{\as¬erasureroot}{\hash}\,,\;
    \isa{\as¬segroot}{\hash}\,,\;
    \isa{\as¬segcount}{\N}
  }
\end{align}

\emph{纠删根}（$\as¬erasureroot$）是一个二叉默克尔树的根，用作对审计报告所需全部数据的承诺，并供后续工作包在需要检索产出数据时使用。因此，保障者用它来验证担保者发送来的数据是否正确，之后审计者也会对其正确性进行验证。详见第 \ref{sec:workpackagesandworkreports} 节。

\emph{片段根}（$\as¬segroot$）是一个常量深度、左偏且以零哈希填充的二叉默克尔树的根，它对每个工作项导出的各个片段的哈希进行承诺。担保者据此验证其被要求导入、用于后续工作包求值的任何重建片段的正确性。亦见第 \ref{sec:workpackagesandworkreports} 节。

\subsubsection{Work Digest}
最后我们定义\emph{工作摘要}，记为 $\workdigest$，它是服务状态可通过工作包内的计算而被改变的数据载体。
\begin{equation}
  \label{eq:workdigest}
  \workdigest \equiv \tuple{
    \begin{alignedat}{9}
      \isa{\wd¬serviceindex&}{\serviceid}\,,\;
      \isa{&\wd¬codehash&}{\hash}\,,\;
      \isa{&\wd¬payloadhash&}{\hash}\,,\;
      \isa{&\wd¬gaslimit&}{\gas}\,,\;
      \isa{&\wd¬result&}{\blob \cup \workerror}\,,\;\\
      \isa{\wd¬gasused&}{\gas}\,,\;
      \isa{&\wd¬importcount&}{\N}\,,\;
      \isa{&\wd¬xtcount&}{\N}\,,\;
      \isa{&\wd¬xtsize&}{\N}\,,\;
      \isa{&\wd¬exportcount&}{\N}
    \end{alignedat}
  }
\end{equation}

工作摘要是一个由若干字段组成的元组。首先是 $\wd¬serviceindex$，即将被改变状态的服务索引（其细化代码此前已执行）。我们包含在上报时该服务代码的哈希 $\wd¬codehash$，它必须如式 \ref{eq:reportcodesarecorrect} 所示被工作报告准确预测。

接着是细化阶段为得到该结果而执行的工作项中“有效载荷”的哈希（$\wd¬payloadhash$）。这在当下没有直接作用，但会提供给该服务的累积逻辑使用。随后是执行该条目“累积”时的 gas 上限 $\wd¬gaslimit$。

还有工作\emph{结果} $\wd¬result$，即代码执行的输出 blob 或错误；若成功则为八位字节序列，否则属于集合 $\workerror$。后者定义为可能的错误集合，形式化地：
\begin{equation}
  \label{eq:workerror}
  \workerror \in \set{ \oog, \panic, \badexports, \oversize, \token{BAD}, \token{BIG} }
\end{equation}

前两者与虚拟机执行相关：$\oog$ 表示气耗尽错误，$\panic$ 表示程序异常终止。其余四者中，第一表示导出数量被不合法地上报；第二表示摘要（细化输出）的大小将超过可接受上限；第三表示在查找锚点区块的后验状态中无法从状态中查找到服务代码；第四表示代码虽可用，但超过了允许的最大大小 $\Cmaxservicecodesize$。

最后，我们用五个字段描述为得出该结果而给核心带来的工作负载水平：包括细化期间实际使用的 gas（$\wd¬gasused$）；从 D$^3$L 导入与导出的片段数量（$\wd¬importcount$ 与 $\wd¬exportcount$）；以及用于计算该工作负载的外部事务数量与其总八位字节大小（$\wd¬xtcount$ 与 $\wd¬xtsize$）。这些值的含义详见第 \ref{sec:workpackagesandworkreports} 节。

为确保公平使用区块的外部事务空间，我们限制工作报告的总体大小：即“成功的细化输出 blobs 的总大小与授权轨迹之和”的上限，从而等效地限制其总体体积：
\begin{align}
  \label{eq:limitworkreportsize}
  &\forall \wrX \in \workreport:
    \len{\wrX_\wr¬authtrace} + \sum_{\wdX \in \wrX_\wr¬digests \cap \blob} \len{\wdX_\wd¬result} \le \Cmaxreportvarsize \\
  &\Cmaxreportvarsize \equiv 48\cdot2^{10}
\end{align}



\subsection{Package Availability Assurances}

我们首先定义中间状态 $\reportspostguarantees$（将在第 \ref{sec:workreportguarantees} 节使用），以及集合 $\justbecameavailable$（新近变为可用的工作报告，稍后在第 \ref{sec:accumulation} 节使用）。二者都需要整合来自保障外部事务 $\xtassurances$ 的信息。

\subsubsection{The Assurances Extrinsic}
保障外部事务由一串\emph{保障（assurance）}值组成，每个验证者最多一个。每条保障包含一串二值（即比特串），每个核心对应一个比特，另加签名与保障者的验证者索引。某个索引位置上的取值为 $1$（若按布尔值解释则为 $\top$）表示该验证者保证其正在为该核心的可用性做出贡献。\footnote{这是种“软”蕴含，因为若不诚实上报，链上没有直接后果。关于该蕴含的更多信息见第 \ref{sec:assurance} 节。}形式化地：
\begin{align}
  \label{eq:xtassurances}
  \xtassurances \in \sequence[\mathsf{:\Cvalcount}]{\tuple{
    \isa{\xa¬anchor}{\hash},\,
    \isa{\xa¬availabilities}{\bitstring[\Ccorecount]},\,
    \isa{\xa¬assurer}{\valindex},\,
    \isa{\xa¬signature}{\edsignaturebase}
  }}
\end{align}

所有保障都必须锚定在父区块上，并按验证者索引排序：
\begin{align}
  \forall a &\in \xtassurances : a_\xa¬anchor = \H_\¬parent \\
  \forall i &\in \set{ 1 \dots \len{\xtassurances} } : \xtassurances\subb{i - 1}_\xa¬assurer < \xtassurances\subb{i}_\xa¬assurer
\end{align}

签名必须出自该保障的验证者的公钥，其签名消息为父哈希 $\H_\¬parent$ 与上述比特串的序列化：
\begin{align}
  \label{eq:assurancesig}
  &\forall a \in \xtassurances : a_\xa¬signature \in \edsignature{\activeset\subb{a_\xa¬assurer}_\vk¬ed}{\Xavailable \concat \blake{\encode{\H_\¬parent, a_\xa¬availabilities}}} \\
  &\Xavailable \equiv \token{\$jam\_available}
\end{align}

仅当相应核心上存在等待可用性的报告时，某比特才允许被置位：
\begin{equation}
  \forall a \in \xtassurances, \cX \in \coreindex :
  \quad a_\xa¬availabilities\subb{\cX} \Rightarrow \reportspostjudgement\subb{\cX} \ne \none
\end{equation}

\subsubsection{Available Reports}
当且仅当在该区块的保障外部事务中，显然有超过 \twothirds 的验证者将其核心标记为置位时，一个工作报告被认为\emph{可用}。形式化地，我们将新近可用的工作报告序列 $\justbecameavailable$ 定义为：
\begin{align}
  \label{eq:availableworkreports}
  \justbecameavailable &\equiv \sq{\build{
      \reportspostjudgement\subb{\cX}_\rs¬workreport
    }{
      \cX \orderedin \coreindex,\;
      \sum_{a \in \xtassurances}\!a_\xa¬availabilities\subb{\cX}\,>\,\twothirds\,\Cvalcount
    }}
\end{align}

该值用于定义 $\accountspost$ 与 $\reportspostguarantees$。我们将 $\reportspostguarantees$ 定义为与 $\reportspostjudgement$ 等价，但移除了那些已变为可用或已超时的条目：
\begin{align}
  \label{eq:reportspostguaranteesdef}
  \forall \cX \in \coreindex: \reportspostguarantees\subb{\cX} \equiv \begin{cases}
    \none &\when\reports\subb{\cX}_\rs¬workreport \in \justbecameavailable \vee \H_\¬timeslot \ge \reportspostjudgement\subb{\cX}_\rs¬timestamp + \Cassurancetimeoutperiod\\
    \reportspostjudgement\subb{\cX} &\otherwise
  \end{cases}
\end{align}



\subsection{Guarantor Assignments}\label{sec:coresandvalidators}

每个区块中，每个核心都唯一地分配给 3 个验证者来为其工作报告提供担保。在 $\Cvalcount = 1{,}023$ 个验证者与 $\Ccorecount = 341$ 个核心下，确有 $\nicefrac{\Cvalcount}{\Ccorecount} = 3$。分配给每个验证者的核心索引以及验证者的密钥，记为 $\guarantorassignments$：
\begin{equation}
  \guarantorassignments \in \tuple{\sequence[\Cvalcount]{\coreindex}, \allvalkeys}
\end{equation}

我们通过使用历元熵（epochal entropy）与周期轮转对验证者进行洗牌，从而确定任一给定验证者被分配到的核心，以帮助提升网络的安全性与活性。我们使用 $\entropy_2$ 作为历元熵，而不是 $\entropy_1$，以避免“分叉放大（fork-magnification）”的可能——在历元末对链状态存在不确定性的情况下，这可能在自然收敛前引起两个确立的分叉。

定义置换函数 $P$、轮转函数 $R$，以及最终的担保者分配 $\guarantorassignments$ 如下：
\begin{align}
  R(\mathbf{c}, n) &\equiv \sq{\build{(x + n) \bmod \Ccorecount}{x \orderedin \mathbf{c}}}\\
  P(e, t) &\equiv R\left(
    \fyshuffle{\sq{\build{\ffrac{\Ccorecount \cdot i}{\Cvalcount}}{i \orderedin \valindex}}, e},
    \ffrac{t \bmod \Cepochlen}{\Crotationperiod}
  \right)\\
  \guarantorassignments &\equiv \tup{P(\entropy'_2, \thetime'), \Phi(\activeset')}
\end{align}

我们还定义 $\guarantorassignmentsunderlastrotation$，它等价于在上一轮轮转下应有的 $\guarantorassignments$ 值：
\begin{equation}
  \label{eq:priorassignments}
  \begin{aligned}
    \using \tup{e, \mathbf{k}} &= \begin{cases}
      \tup{\entropy'_2, \activeset'} &\when \displaystyle\ffrac{\thetime' - \Crotationperiod}{\Cepochlen} = \ffrac{\thetime'}{\Cepochlen}\\
      \tup{\entropy'_3, \previousset'} &\otherwise
    \end{cases} \\
    \guarantorassignmentsunderlastrotation &\equiv \tup{
      P(e, \thetime' - \Crotationperiod),
      \Phi(\mathbf{k})
    }
  \end{aligned}
\end{equation}



\subsection{Work Report Guarantees}\label{sec:workreportguarantees}

我们先定义担保外部事务 $\xtguarantees$：它由一系列\emph{担保（guarantees）}构成，每个核心最多一个；每条包含一个\emph{工作报告}、一个凭证 $\xg¬credential$ 及其对应的时间槽 $\xg¬timeslot$。每条担保的核心索引必须唯一，并按该索引升序排列。形式化地：
\begin{align}\label{eq:guaranteesextrinsic}
  \xtguarantees &\in \sequence[:\Ccorecount]{\tuple{
    \isa{\xg¬workreport}{\workreport},\,
    \isa{\xg¬timeslot}{\timeslot},\,
    \isa{\xg¬credential}{\sequence[2:3]{\tuple{\valindex, \edsignaturebase}}}
  }} \\
  \xtguarantees &= \sqorderuniqby{(g_\xg¬workreport)_\wr¬core}{g \in \xtguarantees}
\end{align}

凭证是 2 或 3 个元组的序列（唯一的验证者索引与签名）。凭证必须按验证者索引排序：
\begin{align}
  \forall g &\in \xtguarantees : g_\xg¬credential = \sqorderuniqby{v}{\tup{v, s} \in g_\xg¬credential}
\end{align}

签名必须出自凭证中标识的验证者的公钥，签名消息为该工作报告哈希的序列化。签名验证者必须在对应的核心上被分配：若担保时间槽与本区块处于同一轮，则使用本区块的分配 $\guarantorassignments$；否则使用最近一次之前的分配 $\guarantorassignmentsunderlastrotation$：
\begin{align}
  \label{eq:guarantorsig}
  &\begin{aligned}
    &\begin{aligned}
      \forall \tup{\xg¬workreport, \xg¬timeslot, \xg¬credential} &\in \xtguarantees,\\
      \forall \tup{v, s} &\in \xg¬credential
    \end{aligned} :
      \abracegroup[\,]{
        &s \in \edsignature{(\mathbf{k}\sub{v})_\vk¬ed}{\Xguarantee\concat\blake{\xg¬workreport}}\\
        &\mathbf{c}\sub{v} = \wrX_\wr¬core \wedge \Crotationperiod(\floor{\nicefrac{\thetime'}{\Crotationperiod}} - 1) \le \xg¬timeslot \le \thetime'\\
      }\\
      &k \in \reporters \Leftrightarrow \exists \tup{\xg¬workreport, \xg¬timeslot, \xg¬credential} \in \xtguarantees, \exists \tup{v, s} \in \xg¬credential: k = (\mathbf{k}\sub{v})_\vk¬ed\\
      &\quad\where \tup{\mathbf{c}, \mathbf{k}} = \begin{cases}
        \guarantorassignments &\when \displaystyle \ffrac{\thetime'}{\Crotationperiod} = \ffrac{t}{\Crotationperiod} \\
        \guarantorassignmentsunderlastrotation &\otherwise
      \end{cases}
  \end{aligned}\\
  &\Xguarantee \equiv \token{\$jam\_guarantee}
\end{align}

注意：每个在凭证中出现签名的验证者，其 Ed25519 公钥都会被放入\emph{报告者（reporters）}集合 $\reporters$ 中。该集合用于第 \ref{sec:bookkeeping} 节的验证者活动统计记账系统。

\newcommand*{\local¬incomingcontexts}{\mathbf{x}}
\newcommand*{\local¬incomingpackagehashes}{\mathbf{p}}

我们用 $\incomingreports$ 表示当前外部事务 $\theextrinsic$ 中的工作报告集合：
\begin{align}\label{eq:incomingworkreports}
  \using\incomingreports = \set{ \build { \xgX_\xg¬workreport }{ \xgX \in \xtguarantees } }
\end{align}

若某核心上已有等待可用性的报告，则不得再在其上提交新的报告。报告仅在其“授权者哈希”存在于该核心的“授权者池”中时才有效。形式化地：
\begin{equation}\label{eq:reportcoresareunusedortimedout}
  \forall \wrX \in \incomingreports :
    \reportspostguarantees\subb{\wrX_\wr¬core} = \none \wedge \wrX_\wr¬authorizer \in \authpool\subb{\wrX_\wr¬core}
\end{equation}

我们要求每个工作报告中每个工作摘要为“累积”分配的 gas 符合其服务的最小 gas 要求；同时要求所有工作报告的“累积”分配 gas 总量不超过整体上限 $\Creportaccgas$：
\begin{equation}
  \forall \wrX \in \incomingreports:
    \sum_{\wdX \in \wrX_\wr¬digests}\!(\wdX_\wd¬gaslimit) \le \Creportaccgas \ \wedge \ 
    \forall \wdX \in \wrX_\wr¬digests: \wdX_\wd¬gaslimit \ge \accounts\subb{\wdX_\wd¬serviceindex}_\sa¬minaccgas
\end{equation}



\subsubsection{Contextual Validity of Reports}\label{sec:contextualvalidity}

为方便起见，我们定义两个等价物 $\local¬incomingcontexts$ 与 $\local¬incomingpackagehashes$，分别表示外部事务中所有的上下文与工作包哈希集合：
\begin{equation}
    \using \local¬incomingcontexts \equiv \set{ \build { \wrX_\wr¬context }{ \wrX \in \incomingreports } }\ ,\quad
    \local¬incomingpackagehashes \equiv \set{ \build { (\wrX_\wr¬avspec)_\as¬packagehash }{ \wrX \in \incomingreports } }
\end{equation}

不得出现重复的工作包哈希（即两个工作报告对应同一个包）。因此，我们要求 $\local¬incomingpackagehashes$ 的基数等于工作报告序列 $\incomingreports$ 的长度：
\begin{equation}
  \len{\local¬incomingpackagehashes} = \len{\incomingreports}
\end{equation}

我们要求“锚点区块”处于最近的 $\Crecenthistorylen$ 个区块之内，并且其详情正确：即它必须出现在我们的最近区块序列 $\recenthistorypostparentstaterootupdate$ 中：
\begin{align}
  \forall x \in \local¬incomingcontexts : \exists y \in \recenthistorypostparentstaterootupdate : x_\wc¬anchorhash = y_\rh¬headerhash \wedge x_\wc¬anchorpoststate = y_\rh¬stateroot \wedge x_\wc¬anchoraccoutlog = y_\rh¬accoutlogsuperpeak \!\!\!\!\!\!
\end{align}

我们要求每个“查找锚点区块”处于最近的 $\Cmaxlookupanchorage$ 个时间槽之内：
\begin{align}
  \label{eq:limitlookupanchorage}
  \forall x \in \local¬incomingcontexts :\ x_\wc¬lookupanchortime \ge \H_\¬timeslot - \Cmaxlookupanchorage
\end{align}

我们还要求对其有记录；这是少数不能仅依赖链上状态进行检查的条件之一，必须依靠保留最近 $\Cmaxlookupanchorage$ 个区块头序列作为祖先集 $\ancestors$。由于通过区块头链确定，它仍是确定性且可计算的。形式化地：
\begin{align}
  \forall x \in \local¬incomingcontexts :\ \exists h \in \ancestors: h_\¬timeslot = x_\wc¬lookupanchortime \wedge \blake{h} = x_\wc¬lookupanchorhash
\end{align}

我们要求报告的工作包不应与过去已上报的某个工作包相同；即该工作包不应出现在我们的处理管线的任何环节中。形式化地：
\begin{align}
  &\using \mathbf{q} = \set{\build{
      (\wrX_\wr¬avspec)_\as¬packagehash
    }{
      \tup{\wrX, \mathbf{d}} \in \concatall{\ready}
    }} \\
  &\using \mathbf{a} = \set{\build{
      ((\wrX_\rs¬workreport)_\wr¬avspec)_\as¬packagehash
    }{
      \wrX \in \reports, \wrX \ne \none
    }} \\
  &\forall p \in \local¬incomingpackagehashes,
    p \not\in \bigcup_{x \in \recenthistory}\keys{x_\rh¬reportedpackagehashes}
      \cup
      \bigcup_{x \in \accumulated}x
      \cup \mathbf{q}
      \cup \mathbf{a}
\end{align}

若存在先决工作包，或在“片段根查找”中提到任何工作包，我们要求这些工作包要么在本外部事务中、要么在我们的最近历史中：
\begin{align}
  &\begin{aligned}
    &\forall \wrX \in \incomingreports,
    \forall p \in (\wrX_\wr¬context)_\wc¬prerequisites \cup
      \keys{\wrX_\wr¬srlookup} :\\
    &\quad p \in \local¬incomingpackagehashes \cup \set{
      \build{x}{x \in \keys{b_\rh¬reportedpackagehashes},\, b \in \recenthistory}}
  \end{aligned}
\end{align}

我们要求在“片段根查找”中提及的任何片段根，都能够基于我们最近的工作包历史以及当前区块得到验证为正确：
\begin{align}
  &\using \local¬incomingpackagehashes = \set{ \build {
    \kv{
      ((g_\xg¬workreport)_\wr¬avspec)_\as¬packagehash
    }{
      ((g_\xg¬workreport)_\wr¬avspec)_\as¬segroot
    }
  }{
    g \in \xtguarantees
  } } \\
  &\forall \wrX \in \incomingreports: \wrX_\wr¬srlookup \subseteq \local¬incomingpackagehashes \cup \bigcup_{b \in \recenthistory} b_\rh¬reportedpackagehashes
\end{align}

（注意：这些检查允许在表面上存在依赖环的工作报告被接受。我们不认为这是问题：预累积阶段事实上保证在这些情况下不会发生累积，这些报告会被简单地忽略。）

最后，我们要求外部事务中的所有工作摘要都能够为其对应的服务预测出正确的代码哈希：
\begin{align}\label{eq:reportcodesarecorrect}
  \forall \wrX \in \incomingreports, \forall \wdX \in \wrX_\wr¬digests : \wdX_\wd¬codehash = \accounts\subb{\wdX_\wd¬serviceindex}_\sa¬codehash
\end{align}



\subsection{Transitioning for Reports}

我们将 $\reportspostassurances$ 定义为与 $\reportspostguarantees$ 等价，但若外部事务替换了某个条目，则该核心位置的新值包含当前时间 $\thetime'$，这样一来在经过足够时间后即可不考虑其可用性而被替换（见式 \ref{eq:reportcoresareunusedortimedout}）。
\begin{equation}
    \forall \cX \in \coreindex : \reportspostassurances\subb{\cX} \equiv \begin{cases}
      \tup{\¬workreport,\,\is{\rs¬timestamp}{\thetime'}} &\when \exists \tup{\¬workreport,\,\xg¬timeslot,\,\xg¬credential} \in \xtguarantees, \¬workreport_\wr¬core = \cX \\
      \reportspostguarantees\subb{\cX} &\otherwise
    \end{cases}
\end{equation}

至此，本节关于“报告与保障”的内容结束。我们已经完整给出了 $\reportspostassurances$ 的定义，并配合 $\justbecameavailable$，可用于第 \ref{sec:accumulation} 节，描述一份工作报告一经担保且变为可用后发生的那部分状态转换。
