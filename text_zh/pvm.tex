\section{Polkadot Virtual Machine}\label{sec:virtualmachine}

%TODO: #446 内存的前 64KB 永远不可访问。

\subsection{Basic Definition}
\newcommand*{\instr}[1]{\text{{\small \texttt{#1}}}}
\newcommand*{\regs}{\sequence[13]{\pvmreg}}
\newcommand*{\reg}{{\registers}}
\newcommand*{\mem}{{\memory}}
\newcommand*{\memr}{\cyclic{\mem}}
\newcommand*{\memwr}{\cyclic{\mem'}}
\newcommand*{\rnp}[1]{P(#1)}
\newcommand*{\rnq}[1]{Z(#1)}
\newcommand*{\continue}{\blacktriangleright}
\newcommand*{\gascost}{\gascounter_\Delta}
\newcommand*{\instrlen}{\ell}
\newcommand*{\revbitsfunc}[1]{\overleftarrow{\fnoctetstobits}_{#1}}
\newcommand*{\revunbitsfunc}[1]{\revbitsfunc{#1}^{-1}}
\newcommand*{\bitsfunc}[1]{\fnoctetstobits_{#1}}
\newcommand*{\unbitsfunc}[1]{\bitsfunc{#1}^{-1}}
\newcommand*{\bits}[1]{\bitsn{8}{#1}}
\newcommand*{\unbits}[1]{\unbitsn{8}{#1}}
\newcommand*{\bitsn}[2]{\bitsfunc{#1}(#2)}
\newcommand*{\unbitsn}[2]{\unbitsfunc{#1}(#2)}
\newcommand*{\RA}{\token{RA}}
\newcommand*{\SP}{\token{SP}}
\newcommand*{\T}{\token{T}}
\renewcommand*{\S}{\token{S}}
\newcommand*{\A}{\token{A}}
\newcommand*{\basicblocks}{\varpi}
\newcommand*{\instructions}{\zeta}
\newcommand*{\immed}{\nu}
\newcommand*{\deblob}{\text{deblob}}
\newcommand*{\smod}{\text{smod}}
\newcommand*{\rtz}{\text{rtz}}

我们声明通用的 \textsc{pvm} 函数 $\Psi$。我们假设存在一个单步调用函数 $\Psi_1$，并将完整的 \textsc{pvm} 定义为该类变更的递归序列，直到单步变更导致停机条件为止。我们另外定义函数 $\deblob$，用于从程序 blob 中提取指令数据、操作码位掩码以及动态跳转表：
\begin{align}
  \Psi&\colon \abracegroup{
    \tuple{\blob, \pvmreg, \gas, \regs, \ram} &\to \tuple{\set{\halt, \panic, \oog} \cup \set{\fault, \host} \times \pvmreg, \pvmreg, \signedgas, \regs, \ram}\\
    \tup{\mathbf{p}, \imath, \gascounter, \registers, \mem} &\mapsto \begin{cases}
      \Psi(\mathbf{p}, \imath', \gascounter', \registers', \mem') &\when \varepsilon = \continue\\
      \tup{\oog, \imath, \gascounter', \registers, \mem} &\when \gascounter' < 0\\
      \tup{\varepsilon, 0, \gascounter', \registers', \mem'} &\when \varepsilon \in \set{ \panic, \halt }\\
      \tup{\varepsilon, \imath, \gascounter', \registers, \mem} &\otherwise
    \end{cases} \\
    \where \tup{\varepsilon, \imath', \gascounter', \registers', \mem'} &= \begin{cases}
      \Psi_1(\mathbf{c}, \mathbf{k}, \mathbf{j}, \imath, \gascounter, \registers, \mem) &\when \tup{\mathbf{c}, \mathbf{k}, \mathbf{j}} = \deblob(\mathbf{p}) \\
      \tup{\panic, \imath, \gascounter, \registers, \mem} &\otherwise
    \end{cases}
  }\\
  \deblob&\colon\abracegroup{
    \blob &\to \tuple{\blob, \bitstring, \sequence{\pvmreg}} \cup \error \\
    \mathbf{p} &\mapsto \begin{cases}
      \tup{\mathbf{c}, \mathbf{k}, \mathbf{j}} &\when \exists!\,\mathbf{c}, \mathbf{k}, \mathbf{j} : \mathbf{p} = \encode{\len{\mathbf{j}}} \concat \encode[1]{z} \concat \encode{\len{\mathbf{c}}} \concat \encode[z]{\mathbf{j}} \concat \encode{\mathbf{c}} \concat \encode{\mathbf{k}}\,,\ \len{\mathbf{k}} = \len{\mathbf{c}} \\
      \error &\otherwise
    \end{cases} \\
  }
\end{align}

\textsc{pvm} 的退出原因 $\varepsilon \in \set{\halt, \panic, \oog} \cup \set{\fault, \host} \times \pvmreg$ 可以是常规停机 $\halt$、恐慌 $\panic$ 或气耗尽 $\oog$；或者是宿主调用 $\host$（此时会关联宿主调用标识符）；或者是页故障 $\fault$（此时会关联 \textsc{ram} 的地址）。

假定程序 blob 是有效的（可静态验证），只要尝试执行就一定会消耗一些 gas。即便实际上没有执行任何指令且机器状态未发生变化（也就是说结果状态等于输入参数），依然如此。

在最终停机的情形下——无论是因恐慌还是成功——返回的指令计数器为零。在所有其他情形中，返回的指令计数器索引的是“导致退出发生的那条指令”，机器状态表示该指令\emph{之前}的状态，从而确保 \emph{事实上} 的一致性。为了在这些退出情形之后继续执行，必须调整某些环境因素：对于页故障，需要更改 \textsc{ram}；对于 gas 下溢，需要提供更多的 gas；对于宿主调用，需要将指令计数器加一并执行相应的宿主调用状态转换。

\subsection{Instructions, Opcodes and Skip-distance}

程序 blob $\mathbf{p}$ 被拆分为一系列八位字节（octet），构成\emph{指令数据} $\mathbf{c}$、\emph{操作码位掩码} $\mathbf{k}$，以及\emph{动态跳转表} $\mathbf{j}$。前两者蕴含一条指令序列，进而蕴含一条\emph{基本块序列}，它是后继于某个\emph{块终止}指令的指令索引序列。

后者（动态跳转表）是一系列指向指令数据 blob 的索引；当进行动态计算的跳转时，会从中取值。它被编码为一串自然数（即非负整数），并且每个自然数都用相同的八位字节长度进行编码。该长度即上文的 $z$，其自身在此前被编码。

\textsc{pvm} 按八位字节来计数指令（而非按指令条数），因此有必要定义哪些八位字节表示一条指令的起始（即操作码八位字节），哪些不是。这正是 $\mathbf{k}$（指令操作码位掩码）的用途。我们断言位掩码的长度等于指令 blob 的长度。

\newcommand{\Fskip}{\text{skip}}

我们定义 Skip 函数 $\Fskip$：给定某条指令的操作码在 $\mathbf{c}$（因而也在 $\mathbf{k}$）中的索引，它返回到下一条指令操作码的八位字节距离减一：
\begin{equation}
  \Fskip\colon\abracegroup{
    \N &\to \N\\
    i &\mapsto \min(24,\ j \in \N : \tup{\mathbf{k} \concat \sq{1, 1, \dots}}_{i + 1 + j} = 1)
  }
\end{equation}

Skip 函数会将 $\mathbf{k}$ 追加上一串置位的比特，以确保对最后一条指令 $\Fskip(\len{\mathbf{c}} - 1)$ 的结果是良定义的。

给定某个指令索引 $i$，其操作码可直接表示为 $\mathbf{c}_i$，而前进到下一条指令的八位字节距离为 $1 + \Fskip(i)$。不过，每条指令的“长度”（定义为自操作码起始、用于完整刻画该指令语义的连续八位字节数量）保持为隐式，但至多不超过 16。

我们将 $\instructions$ 定义为与指令 $\mathbf{c}$ 等价，但在其末尾追加无限序列的零，以确保不会发生越界访问。这事实上为最后一条指令的任何本应未定义的参数给出了定义，并确保一旦程序计数器越过程序代码就会触发陷阱。形式化地：
\begin{equation}\label{eq:instructions}
  \instructions \equiv \mathbf{c} \concat \sq{0, 0, \dots}
\end{equation}

\subsection{Basic Blocks and Termination Instructions}

具有下列操作码的指令被视为基本块终止指令；除了 $\token{trap}$ 与 $\token{fallthrough}$ 之外，它们对应的都是可能将指令计数器设置为“并非既有值加上本指令跳过距离”的指令：
\begin{itemize}
  \item Trap and fallthrough: $\token{trap}$
  , $\token{fallthrough}$
  \item Jumps: $\token{jump}$
  , $\token{jump\_ind}$
  \item Load-and-Jumps: $\token{load\_imm\_jump}$
  , $\token{load\_imm\_jump\_ind}$
  \item Branches: $\token{branch\_eq}$
  , $\token{branch\_ne}$
  , $\token{branch\_ge\_u}$
  , $\token{branch\_ge\_s}$
  , $\token{branch\_lt\_u}$
  , $\token{branch\_lt\_s}$
  , $\token{branch\_eq\_imm}$
  , $\token{branch\_ne\_imm}$
  \item Immediate branches: $\token{branch\_lt\_u\_imm}$
  , $\token{branch\_lt\_s\_imm}$
  , $\token{branch\_le\_u\_imm}$
  , $\token{branch\_le\_s\_imm}$
  , $\token{branch\_ge\_u\_imm}$
  , $\token{branch\_ge\_s\_imm}$
  , $\token{branch\_gt\_u\_imm}$
  , $\token{branch\_gt\_s\_imm}$
\end{itemize}

我们将该集合（以操作码索引而非名称表示）记为 $T$，它是所有有效操作码索引 $U$ 的子集。我们定义表示基本块起始位置的指令操作码索引集 $\basicblocks$：
\begin{equation}
  \basicblocks \equiv \left(\set{0} \cup \set{\build{n + 1 + \Fskip(n)}{n \in \Nmax{\len{\mathbf{c}}} \wedge \mathbf{k}\sub{n} = 1 \wedge \mathbf{c}\sub{n} \in T}}\right) \cap \set{\build{n}{\mathbf{k}\sub{n} = 1 \wedge \mathbf{c}\sub{n} \in U}}
\end{equation}

\subsection{Single-Step State Transition}

我们现在需要定义单步的 \textsc{pvm} 状态转换函数 $\Psi_1$：
\begin{equation}
  \Psi_1\colon \abracegroup{
    \tuple{\blob, \bitstring, \sequence{\pvmreg}, \pvmreg, \gas, \regs, \ram} &\to \tuple{\set{\panic, \halt, \continue } \cup \set{\fault, \host} \times \pvmreg, \pvmreg, \signedgas, \regs, \ram}\\
    \tup{\mathbf{c}, \mathbf{k}, \mathbf{j}, \imath, \gascounter, \registers, \mem} &\mapsto \tup{\varepsilon^*, \imath^*, \gascounter^*, \registers^*, \mem^*}
  }
\end{equation}

在执行指令的过程中可能会访问 \textsc{ram}。当需要访问的 \textsc{ram} 索引小于 $2^{16}$ 时，机器总是立即恐慌并且不再改变其状态（无论该值看起来是否可访问）。否则，若所给的 \textsc{ram} 索引不可访问，则机器状态保持不变，并以故障作为退出原因；此时返回要读取的最低不可访问\emph{页地址}。类似地，当必须修改 \textsc{ram} 而又无法进行可变访问时，机器状态保持不变，并以故障作为退出原因；此时返回要写入的最低不可访问页地址。

形式化地，令 $\mathbf{r}$ 与 $\mathbf{w}$ 分别为在计算 $\Psi_1$ 的结果时必须对 $\mem$ 进行读取与写入索引的集合。我们定义内存访问的异常执行状态 $\varepsilon^\mu$；若其不为 $\continue$，则将单独决定 $\Psi_1$ 的返回值，如下：
\begin{align}
  \using \mathbf{x} &= \set{\build{x}{x \in \mathbf{r} \wedge x \bmod 2^{32} \not\in \readable\mem\ \vee\ x \in \mathbf{w} \wedge x \bmod 2^{32} \not\in \writable\mem}} \\
  \tup{\varepsilon^*, \imath^*, \gascounter^*, \registers^*, \mem^*} &= \begin{cases}
    \tup{\varepsilon, \imath', \gascounter', \registers', \mem'} &\when \mathbf{x} = \emset \\
    \tup{\panic, \imath, \gascounter, \registers, \mem} &\when \min(\mathbf{x}) \bmod 2^{32} < 2^{16} \\
    \tup{\fault \times \Cpvmpagesize\floor{\min(\mathbf{x}) \bmod 2^{32} \div \Cpvmpagesize}, \imath, \gascounter, \registers, \mem} &\otherwise
  \end{cases}
\end{align}

我们将 $\varepsilon$ 及常规执行（以撇号表示事后值）下机器状态各项的后验值与下表保持一致。对一条指令进行状态转换时，通常会有若干条件成立，而指令的定义本质上是这些规则的例外。具体而言：机器不会停机，指令计数器递增一，剩余 gas 按照该指令类型消减，\textsc{ram} 与寄存器保持不变。形式化地：
\begin{equation}
  \varepsilon = \continue,\quad \imath' = \imath + 1 + \Fskip(\imath),\quad \gascounter' = \gascounter - \gascost,\quad \registers' = \registers,\quad\mem' = \mem \text{ 除非另有指明 }
\end{equation}

当 $\Psi_1$ 进入 $\varepsilon^\mu$ 情形时

我们定义若干不同八位字节宽度下的有符号／无符号转换：
\begin{align}
  \label{eq:signedfunc}
  \signfunc{n \in \N}&\colon\abracegroup{
    \Nbits{8n} &\to \Z_{-2^{8n-1}\dots2^{8n-1}}\\
    a &\mapsto \begin{cases}
      a &\when a < 2^{8n-1} \\
      a -\ 2^{8n} &\otherwise
    \end{cases}
  }\\
  \unsignfunc{n \in \N}&\colon\abracegroup{
    \Z_{-2^{8n-1}\dots2^{8n-1}} &\to \Nbits{8n}\\
    a &\mapsto (2^{8n} + a) \bmod 2^{8n}
  }\\
  \label{eq:bitsfunc}
  \bitsfunc{n\in\N}&\colon\abracegroup{
    \Nbits{8n} &\to \bitstring[8n]\\
    x &\mapsto \mathbf{y}: \forall i \in \Nmax{8n} : \mathbf{y}\subb{i} \Leftrightarrow \ffrac{x}{2^i}\bmod 2
  }\\
  \unbitsfunc{n\in\N}&\colon\abracegroup{
    \bitstring[8n] &\to \Nbits{8n}\\
    \mathbf{x} &\mapsto y: \sum_{i \in \Nmax{8n}} \mathbf{x}\sub{i} \cdot 2^i
  }\\
  \label{eq:revbitsfunc}
  \revbitsfunc{n\in\N}&\colon\abracegroup{
    \Nbits{8n} &\to \bitstring[8n]\\
    x &\mapsto \mathbf{y}: \forall i \in \Nmax{8n} : \mathbf{y}[8n - 1 - i] \Leftrightarrow \ffrac{x}{2^i}\bmod 2
  }\\
  \revunbitsfunc{n\in\N}&\colon\abracegroup{
    \bitstring[8n] &\to \Nbits{8n}\\
    \mathbf{x} &\mapsto y: \sum_{i \in \Nmax{8n}} \mathbf{x}\sub{8n - 1 - i} \cdot 2^i
  }
\end{align}

立即数采用小端编码（little-endian），其最高有效位为符号位。它们可通过省略更高有效八位字节实现紧凑编码：若数值的 \textsc{msb} 为 0，则被省略的八位字节被视为 0；否则视为 255。这样就能同时对正值与负值进行紧凑表示。于是我们定义对 $n$ 个八位字节输入进行的符号扩展函数为 $\fnsext{n}$：
\begin{align}\label{eq:signedextension}
  \fnsext{n \in \set{0, 1, 2, 3, 4, 8}}\colon\abracegroup{
    \Nbits{8n} &\to \pvmreg\\
    x &\mapsto x + \ffrac{x}{2^{8n-1}}(2^{64}-2^{8n})
  }
\end{align}

所有由静态跳转、调用或分支引起的程序计数器变更，其目标必须对齐到基本块的开始处，否则发生恐慌。假设其他条件均不变。形式化地：
\begin{equation}
  \token{branch}(b, C) \implies \tup{\varepsilon, \imath'} = \begin{cases}
    \tup{\continue, \imath} &\when \lnot C \\
    \tup{\panic, \imath} &\otherwhen b \not\in \basicblocks \\
    \tup{\continue, b} &\otherwise
  \end{cases}
\end{equation}

下一条指令位置由动态计算得到的跳转，必须使用一个可用以索引跳转表 $\mathbf{j}$ 的地址。由于工具链的一个特性\footnote{流行的代码生成后端 \textsc{llvm} 在其代码生成中要求并假定动态计算的跳转目标总是满足某种内存对齐。鉴于目前我们依赖该工具链，因此必须遵循其假设。}，我们将指令所需的动态地址定义为“跳转表索引先加一再乘以我们的跳转对齐因子 $\Cpvmdynaddralign = 2$”。

与其他非常规的程序计数器变更一样，目标代码索引必须位于基本块的起始处，否则恐慌。形式化地：
\begin{equation}\label{eq:jumptablealignment}
  \token{djump}(a) \implies \tup{\varepsilon, \imath'} = \begin{cases}
    \tup{\halt, \imath} &\when a = 2^{32} - 2^{16}\\
    \tup{\panic, \imath} &\otherwhen a = 0 \vee a > \len{\mathbf{j}}\cdot\Cpvmdynaddralign \vee a \bmod \Cpvmdynaddralign \ne 0 \vee \mathbf{j}_{(\nicefrac{a}{\Cpvmdynaddralign}) - 1} \not\in \basicblocks \\
    (\continue, \mathbf{j}_{(\nicefrac{a}{\Cpvmdynaddralign}) - 1}) &\otherwise
  \end{cases}
\end{equation}

\subsection{Instruction Tables}\label{sec:instructiontables}

只有下表中被定义且其操作码在位掩码中对应比特被置位的指令才被视为有效；否则，该指令的行为如同其操作码等于零。若令 $U$ 表示所有有效的操作码索引，则形式化地：
\begin{equation}
  \text{opcode}\colon\abracegroup{
    \N &\to \N\\
    n &\mapsto \begin{cases}
    \mathbf{c}\sub{n} &\when \mathbf{k}\sub{n} = 1 \wedge \mathbf{c}\sub{n} \in U \\
    0 &\otherwise
    \end{cases}
  }
\end{equation}

我们假定跳过长度 $\ell$ 良定义：
\begin{equation}
  \ell \equiv \Fskip(\imath)
\end{equation}

\subsubsection{无参数指令}

\newcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{20mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  0&\token{trap}&1&$\varepsilon = \panic$\\
  \mrule
  1&\token{fallthrough}&1&\\
  \bottomrule
\end{longtable}

\subsubsection{含一个立即数参数的指令}
\begin{equation}
\begin{aligned}
  \using l_X = \min(4, \ell) \,,\quad
  \immed_X \equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+1}{l_X}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  10&\token{ecalli}&1&$\varepsilon = \host \times \immed_X$\\
\bottomrule
\end{longtable}

\subsubsection{含一个寄存器与一个扩展宽度立即数（extended-width immediate）的指令}
\begin{equation}
  \using r_A = \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad
  \reg'_A \equiv \reg'_{r_A} \,,\quad
  \immed_X \equiv \decode[8]{\instructions\subrange{\imath+2}{8}}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  20&\token{load\_imm\_64}&1&$\reg'_A = \immed_X$\\
\bottomrule
\end{longtable}

\subsubsection{含两个立即数参数的指令}
\begin{equation}
\begin{aligned}
    \using l_X &= \min(4, \instructions_{\imath+1} \bmod 8) \,,\quad&
    \immed_X &\equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}} \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
    \immed_Y &\equiv \sext{l_Y}{\decode[l_Y]{\instructions\subrange{\imath+2+l_X}{l_Y}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  30&\token{store\_imm\_u8}&1&$\memwr_{\immed_X} = \immed_Y \bmod 2^8 $\\ \mrule
  31&\token{store\_imm\_u16}&1&$\memwr\subrange{\immed_X}{2} = \encode[2]{\immed_Y \bmod 2^{16}}$\\ \mrule
  32&\token{store\_imm\_u32}&1&$\memwr\subrange{\immed_X}{4} = \encode[4]{\immed_Y \bmod 2^{32}}$\\ \mrule
  33&\token{store\_imm\_u64}&1&$\memwr\subrange{\immed_X}{8} = \encode[8]{\immed_Y}$\\
\bottomrule
\end{longtable}

\subsubsection{含一个偏移量参数的指令}
\begin{equation}
\begin{aligned}
  \using l_X = \min(4, \ell) \,,\quad
  \immed_X \equiv \imath + \signfunc{l_X}(\decode[l_X]{\instructions\subrange{\imath+1}{l_X}})
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  40&\token{jump}&1&$\token{branch}(\immed_X, \top)$\\
\bottomrule
\end{longtable}

\subsubsection{含一个寄存器与一个立即数的指令}
\begin{equation}
\begin{aligned}
    \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
    \immed_X &\equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  50&\token{jump\_ind}&1&$\token{djump}((\reg_A + \immed_X) \bmod 2^{32})$\\ \mrule
  51&\token{load\_imm}&1&$\reg'_A = \immed_X$\\ \mrule
  52&\token{load\_u8}&1&$\reg'_A = \memr_{\immed_X}$\\ \mrule
  53&\token{load\_i8}&1&$\reg'_A = \sext{1}{\memr_{\immed_X}}$\\ \mrule
  54&\token{load\_u16}&1&$\reg'_A = \decode[2]{\memr\subrange{\immed_X}{2}}$\\ \mrule
  55&\token{load\_i16}&1&$\reg'_A = \sext{2}{\decode[2]{\memr\subrange{\immed_X}{2}}}$\\ \mrule
  56&\token{load\_u32}&1&$\reg'_A = \decode[4]{\memr\subrange{\immed_X}{4}}$\\ \mrule
  57&\token{load\_i32}&1&$\reg'_A = \sext{4}{\decode[4]{\memr\subrange{\immed_X}{4}}}$\\ \mrule
  58&\token{load\_u64}&1&$\reg'_A = \decode[8]{\memr\subrange{\immed_X}{8}}$\\ \mrule
  59&\token{store\_u8}&1&$\memwr_{\immed_X} = \reg_A \bmod 2^8$\\ \mrule
  60&\token{store\_u16}&1&$\memwr\subrange{\immed_X}{2} = \encode[2]{\reg_A \bmod 2^{16}}$\\ \mrule
  61&\token{store\_u32}&1&$\memwr\subrange{\immed_X}{4} = \encode[4]{\reg_A \bmod 2^{32}}$\\ \mrule
  62&\token{store\_u64}&1&$\memwr\subrange{\immed_X}{8} = \encode[8]{\reg_A}$\\
\bottomrule
\end{longtable}

\subsubsection{含一个寄存器与两个立即数的指令}
\begin{equation}
\begin{aligned}
    \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using l_X &= \min(4, \ffrac{\instructions_{\imath+1}}{16} \bmod 8) \,,\quad&
    \immed_X &= \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}} \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
    \immed_Y &= \sext{l_Y}{\decode[l_Y]{\instructions\subrange{\imath+2+l_X}{l_Y}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  70&\token{store\_imm\_ind\_u8}&1&$\memwr_{\reg_A + \immed_X} = \immed_Y \bmod 2^8$\\ \mrule
  71&\token{store\_imm\_ind\_u16}&1&$\memwr\subrange{\reg_A + \immed_X}{2} = \encode[2]{\immed_Y \bmod 2^{16}}$\\ \mrule
  72&\token{store\_imm\_ind\_u32}&1&$\memwr\subrange{\reg_A + \immed_X}{4} = \encode[4]{\immed_Y \bmod 2^{32}}$\\ \mrule
  73&\token{store\_imm\_ind\_u64}&1&$\memwr\subrange{\reg_A + \immed_X}{8} = \encode[8]{\immed_Y}$\\
  \bottomrule
\end{longtable}

\subsubsection{含一个寄存器、一个立即数和一个偏移量的指令}
\begin{equation}
  \begin{aligned}
      \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
      \reg_A &\equiv \reg_{r_A} \,,\quad
      \reg'_A \equiv \reg'_{r_A} \\
      \using l_X &= \min(4, \ffrac{\instructions_{\imath+1}}{16} \bmod 8) \,,\quad&
      \immed_X &= \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}} \\
      \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
      \immed_Y &= \imath + \signfunc{l_Y}(\decode[l_Y]{\instructions\subrange{\imath+2+l_X}{l_Y}})
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  80&\token{load\_imm\_jump}&1&$\token{branch}(\immed_Y, \top)\ ,\qquad \reg_A' = \immed_X$\\ \mrule
  81&\token{branch\_eq\_imm}&1&$\token{branch}(\immed_Y, \reg_A = \immed_X)$\\ \mrule
  82&\token{branch\_ne\_imm}&1&$\token{branch}(\immed_Y, \reg_A \ne \immed_X)$\\ \mrule
  83&\token{branch\_lt\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A < \immed_X)$\\ \mrule
  84&\token{branch\_le\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A \le \immed_X)$\\ \mrule
  85&\token{branch\_ge\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A \ge \immed_X)$\\ \mrule
  86&\token{branch\_gt\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A > \immed_X)$\\ \mrule
  87&\token{branch\_lt\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} < \signed{\immed_X})$\\ \mrule
  88&\token{branch\_le\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} \le \signed{\immed_X})$\\ \mrule
  89&\token{branch\_ge\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} \ge \signed{\immed_X})$\\ \mrule
  90&\token{branch\_gt\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} > \signed{\immed_X})$\\
  \bottomrule
\end{longtable}

\subsubsection{含两个寄存器参数的指令}
\begin{equation}
\begin{aligned}
  \using r_D &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_D &\equiv \reg_{r_D} \,,\quad
  \reg'_D \equiv \reg'_{r_D} \\
  \using r_A &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{32mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  100&\token{move\_reg}&1&$\reg'_D = \reg_A$\\ \mrule
  101&\token{sbrk}&1&$\begin{aligned}
    \reg'_D \equiv &\min(x \in \pvmreg): \\
    &x \ge h\\
    &\Nrange{x}{\reg_A} \not\subseteq \readable{\memory}\\
    &\Nrange{x}{\reg_A} \subseteq \writable{\memory'}
  \end{aligned}$\\ \mrule
  102&\token{count\_set\_bits\_64}&1&$\displaystyle\reg'_D = \sum_{i = 0}^{63}\bitsfunc{8}(\reg_A)\sub{i}$\\ \mrule
  103&\token{count\_set\_bits\_32}&1&$\displaystyle\reg'_D = \sum_{i = 0}^{31}\bitsfunc{4}(\reg_A \bmod 2^{32})\sub{i}$\\ \mrule
  104&\token{leading\_zero\_bits\_64}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{65})\ \where \sum_{i = 0}^{i < n} \revbitsfunc{8}(\reg_A)\sub{i} = 0$\\ \mrule
  105&\token{leading\_zero\_bits\_32}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{33})\ \where \sum_{i = 0}^{i < n} \revbitsfunc{4}(\reg_A \bmod 2^{32})\sub{i} = 0$\\ \mrule
  106&\token{trailing\_zero\_bits\_64}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{65})\ \where \sum_{i = 0}^{i < n} \bitsfunc{8}(\reg_A)\sub{i} = 0$\\ \mrule
  107&\token{trailing\_zero\_bits\_32}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{33})\ \where \sum_{i = 0}^{i < n} \bitsfunc{4}(\reg_A \bmod 2^{32})\sub{i} = 0$\\ \mrule
  108&\token{sign\_extend\_8}&1&$\reg'_D = \unsigned{\signedn{1}{\reg_A \bmod 2^8}}$\\ \mrule
  109&\token{sign\_extend\_16}&1&$\reg'_D = \unsigned{\signedn{2}{\reg_A \bmod 2^{16}}}$\\ \mrule
  110&\token{zero\_extend\_16}&1&$\reg'_D = \reg_A \bmod 2^{16}$\\ \mrule
  111&\token{reverse\_bytes}&1&$\forall i \in \N_8 : \encode[8]{\reg'_D}\sub{i} = \encode[8]{\reg_A}_{7-i}$\\
%  10X&\token{}&1&$\reg'_D = ...$\\ \mrule
\bottomrule
\end{longtable}

注意，上述的 $h$ 指内存堆（heap）的起始位置，它是内存的第二个主要区段，如式 \ref{eq:memlayout} 中定义的 $2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}}$。如果在一个不具备这种内存布局的 \textsc{pvm} 实例上调用 $\token{sbrk}$ 指令，则 $h = 0$。

\subsubsection{含两个寄存器与一个立即数的指令}
\begin{equation}
\begin{aligned}
  \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
  \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_B &\equiv \reg_{r_B} \,,\quad
  \reg'_B \equiv \reg'_{r_B} \\
  \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
  \immed_X &\equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{35mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  120&\token{store\_ind\_u8}&1&$\memwr_{\reg_B + \immed_X} = \reg_A \bmod 2^8$\\ \mrule
  121&\token{store\_ind\_u16}&1&$\memwr\subrange{\reg_B + \immed_X}{2} = \encode[2]{\reg_A \bmod 2^{16}}$\\ \mrule
  122&\token{store\_ind\_u32}&1&$\memwr\subrange{\reg_B + \immed_X}{4} = \encode[4]{\reg_A \bmod 2^{32}}$\\ \mrule
  123&\token{store\_ind\_u64}&1&$\memwr\subrange{\reg_B + \immed_X}{8} = \encode[8]{\reg_A}$\\ \mrule
  124&\token{load\_ind\_u8}&1&$\reg'_A = \memr_{\reg_B + \immed_X}$\\ \mrule
  125&\token{load\_ind\_i8}&1&$\reg'_A = \unsigned{\signedn{1}{\memr_{\reg_B + \immed_X}}}$\\ \mrule
  126&\token{load\_ind\_u16}&1&$\reg'_A = \decode[2]{\memr\subrange{\reg_B + \immed_X}{2}}$\\ \mrule
  127&\token{load\_ind\_i16}&1&$\reg'_A = \unsigned{\signedn{2}{\decode[2]{\memr\subrange{\reg_B + \immed_X}{2}}}}$\\ \mrule
  128&\token{load\_ind\_u32}&1&$\reg'_A = \decode[4]{\memr\subrange{\reg_B + \immed_X}{4}}$\\ \mrule
  129&\token{load\_ind\_i32}&1&$\reg'_A = \unsigned{\signedn{4}{\decode[4]{\memr\subrange{\reg_B + \immed_X}{4}}}}$\\ \mrule
  130&\token{load\_ind\_u64}&1&$\reg'_A = \decode[8]{\memr\subrange{\reg_B + \immed_X}{8}}$\\ \mrule
  131&\token{add\_imm\_32}&1&$\reg'_A = \sext{4}{(\reg_B + \immed_X) \bmod 2^{32}}$\\ \mrule
  132&\token{and\_imm}&1&$\forall i \in \Nmax{64} : \bits{\reg'_A}\sub{i} = \bits{\reg_B}\sub{i} \wedge \bits{\immed_X}\sub{i}$\\ \mrule
  133&\token{xor\_imm}&1&$\forall i \in \Nmax{64} : \bits{\reg'_A}\sub{i} = \bits{\reg_B}\sub{i} \oplus \bits{\immed_X}\sub{i}$\\ \mrule
  134&\token{or\_imm}&1&$\forall i \in \Nmax{64} : \bits{\reg'_A}\sub{i} = \bits{\reg_B}\sub{i} \vee \bits{\immed_X}\sub{i}$\\ \mrule
  135&\token{mul\_imm\_32}&1&$\reg'_A = \sext{4}{(\reg_B \cdot \immed_X) \bmod 2^{32}}$\\ \mrule
  136&\token{set\_lt\_u\_imm}&1&$\reg'_A = \reg_B < \immed_X$\\ \mrule
  137&\token{set\_lt\_s\_imm}&1&$\reg'_A = \signed{\reg_B} < \signed{\immed_X}$\\ \mrule
  138&\token{shlo\_l\_imm\_32}&1&$\reg'_A = \sext{4}{(\reg_B \cdot 2^{\immed_X \bmod 32}) \bmod 2^{32}}$\\ \mrule
  139&\token{shlo\_r\_imm\_32}&1&$\reg'_A = \sext{4}{\floor{\reg_B \bmod 2^{32} \div 2^{\immed_X \bmod 32}}}$\\ \mrule
  140&\token{shar\_r\_imm\_32}&1&$\reg'_A = \unsigned{\floor{\signedn{4}{\reg_B \bmod 2^{32} } \div 2^{\immed_X \bmod 32}}}$\\ \mrule
  141&\token{neg\_add\_imm\_32}&1&$\reg'_A = \sext{4}{(\immed_X + 2^{32} - \reg_B) \bmod 2^{32}}$\\ \mrule
  142&\token{set\_gt\_u\_imm}&1&$\reg'_A = \reg_B > \immed_X$\\ \mrule
  143&\token{set\_gt\_s\_imm}&1&$\reg'_A = \signed{\reg_B} > \signed{\immed_X}$\\ \mrule
  144&\token{shlo\_l\_imm\_alt\_32}&1&$\reg'_A = \sext{4}{(\immed_X \cdot 2^{\reg_B \bmod 32}) \bmod 2^{32}}$\\ \mrule
  145&\token{shlo\_r\_imm\_alt\_32}&1&$\reg'_A = \sext{4}{\floor{\immed_X \bmod 2^{32} \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  146&\token{shar\_r\_imm\_alt\_32}&1&$\reg'_A = \unsigned{\floor{\signedn{4}{\immed_X \bmod 2^{32}} \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  147&\token{cmov\_iz\_imm}&1&$\reg'_A = \begin{cases}
    \immed_X &\when \reg_B = 0\\
    \reg_A &\otherwise
  \end{cases}$\\ \mrule
  148&\token{cmov\_nz\_imm}&1&$\reg'_A = \begin{cases}
    \immed_X &\when \reg_B \ne 0\\
    \reg_A &\otherwise
  \end{cases}$\\ \mrule
  149&\token{add\_imm\_64}&1&$\reg'_A = (\reg_B + \immed_X) \bmod 2^{64}$\\ \mrule
  150&\token{mul\_imm\_64}&1&$\reg'_A = (\reg_B \cdot \immed_X) \bmod 2^{64}$\\ \mrule
  % \sext{8} is a no-op - WTF is this doing here??
  151&\token{shlo\_l\_imm\_64}&1&$\reg'_A = \sext{8}{(\reg_B \cdot 2^{\immed_X \bmod 64}) \bmod 2^{64}}$\\ \mrule
  152&\token{shlo\_r\_imm\_64}&1&$\reg'_A = \sext{8}{\floor{\reg_B \div 2^{\immed_X \bmod 64}}}$\\ \mrule
  153&\token{shar\_r\_imm\_64}&1&$\reg'_A = \unsigned{\floor{\signed{\reg_B} \div 2^{\immed_X \bmod 64}}}$\\ \mrule
  154&\token{neg\_add\_imm\_64}&1&$\reg'_A = (\immed_X + 2^{64} - \reg_B) \bmod 2^{64}$\\ \mrule
  155&\token{shlo\_l\_imm\_alt\_64}&1&$\reg'_A = (\immed_X \cdot 2^{\reg_B \bmod 64}) \bmod 2^{64}$\\ \mrule
  156&\token{shlo\_r\_imm\_alt\_64}&1&$\reg'_A = \floor{\immed_X \div 2^{\reg_B \bmod 64}}$\\ \mrule
  157&\token{shar\_r\_imm\_alt\_64}&1&$\reg'_A = \unsigned{\floor{\signed{\immed_X} \div 2^{\reg_B \bmod 64}}}$\\ \mrule
  158&\token{rot\_r\_64\_imm}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_A)\sub{i} = \bitsfunc{8}(\reg_B)_{(i + \immed_X) \bmod 64}$\\ \mrule
  159&\token{rot\_r\_64\_imm\_alt}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_A)\sub{i} = \bitsfunc{8}(\immed_X)_{(i + \reg_B) \bmod 64}$\\ \mrule
  160&\token{rot\_r\_32\_imm}&1&$\reg'_A = \sext{4}{x} \ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)\sub{i} = \bitsfunc{4}(\reg_B)_{(i + \immed_X) \bmod 32}$\\ \mrule
  161&\token{rot\_r\_32\_imm\_alt}&1&$\reg'_A = \sext{4}{x} \ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)\sub{i} = \bitsfunc{4}(\immed_X)_{(i + \reg_B) \bmod 32}$\\
  \bottomrule
\end{longtable}

\subsubsection{含两个寄存器与一个偏移量的指令}
\begin{equation}
  \begin{aligned}
    \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
    \reg_B &\equiv \reg_{r_B} \,,\quad
    \reg'_B \equiv \reg'_{r_B} \\
    \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
    \immed_X &\equiv \imath + \signfunc{l_X}(\decode[l_X]{\instructions\subrange{\imath+2}{l_X}})
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  170&\token{branch\_eq}&1&$\token{branch}(\immed_X, \reg_A = \reg_B)$\\ \mrule
  171&\token{branch\_ne}&1&$\token{branch}(\immed_X, \reg_A \ne \reg_B)$\\ \mrule
  172&\token{branch\_lt\_u}&1&$\token{branch}(\immed_X, \reg_A < \reg_B)$\\ \mrule
  173&\token{branch\_lt\_s}&1&$\token{branch}(\immed_X, \signed{\reg_A} < \signed{\reg_B})$\\ \mrule
  174&\token{branch\_ge\_u}&1&$\token{branch}(\immed_X, \reg_A \ge \reg_B)$\\ \mrule
  175&\token{branch\_ge\_s}&1&$\token{branch}(\immed_X, \signed{\reg_A} \ge \signed{\reg_B})$\\
\bottomrule
\end{longtable}

\subsubsection{含两个寄存器与两个立即数的指令}

\begin{equation}
  \begin{aligned}
    \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
    \reg_B &\equiv \reg_{r_B} \,,\quad
    \reg'_B \equiv \reg'_{r_B} \\
    \using l_X &= \min(4, \instructions_{\imath+2} \bmod 8) \,,\quad&
    \immed_X &= \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+3}{l_X}}} \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 2)) \,,\quad&
    \immed_Y &= \sext{l_Y}{\decode[l_Y]{\instructions\subrange{\imath+3+l_X}{l_Y}}}
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  180&\token{load\_imm\_jump\_ind}&1&$
    \token{djump}((\reg_B + \immed_Y) \bmod 2^{32}) \ ,\qquad
    \reg_A' = \immed_X
  $\\
  \bottomrule
\end{longtable}

\subsubsection{含三个寄存器参数的指令}
\begin{equation}
\begin{aligned}
  \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
  \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_B &\equiv \reg_{r_B} \,,\quad
  \reg'_B \equiv \reg'_{r_B} \\
  \using r_D &= \min(12, \instructions_{\imath+2}) \,,\quad&
  \reg_D &\equiv \reg_{r_D} \,,\quad
  \reg'_D \equiv \reg'_{r_D} \\
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}[t]{p{8mm} p{20mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  190&\token{add\_32}&1&$\reg'_D = \sext{4}{(\reg_A + \reg_B) \bmod 2^{32}}$\\ \mrule
  191&\token{sub\_32}&1&$\reg'_D = \sext{4}{(\reg_A + 2^{32} - (\reg_B \bmod 2^{32})) \bmod 2^{32}}$\\ \mrule
  192&\token{mul\_32}&1&$\reg'_D = \sext{4}{(\reg_A \cdot \reg_B) \bmod 2^{32}}$\\ \mrule
  193&\token{div\_u\_32}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when \reg_B \bmod 2^{32} = 0\\
    \sext{4}{\floor{(\reg_A \bmod 2^{32}) \div (\reg_B \bmod 2^{32})}} &\otherwise
  \end{cases}$\\ \mrule
  194&\token{div\_s\_32}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when b = 0\\
    \unsigned{a} &\when a = -2^{31} \wedge b = -1\\
    \unsigned{\rtz(a \div b)} &\otherwise \\[2pt]
    \multicolumn{2}{l}{\quad \where a = \signedn{4}{\reg_A \bmod 2^{32}}\,,\ b = \signedn{4}{\reg_B \bmod 2^{32}}}\\
  \end{cases}$\\ \mrule
  195&\token{rem\_u\_32}&1&$\reg'_D = \begin{cases}
    \sext{4}{\reg_A \bmod 2^{32}} &\when \reg_B \bmod 2^{32} = 0\\
    \sext{4}{(\reg_A \bmod 2^{32}) \bmod (\reg_B \bmod 2^{32})} &\otherwise
  \end{cases}$\\ \mrule
  196&\token{rem\_s\_32}&1&$\reg'_D = \begin{cases}
    0 &\when a = -2^{31} \wedge b = -1 \\
    \unsigned{\smod(a, b)} &\otherwise \\[2pt]
    \multicolumn{2}{l}{\quad \where a = \signedn{4}{\reg_A \bmod 2^{32}}\,,\ b = \signedn{4}{\reg_B \bmod 2^{32}}}\\
  \end{cases}$\\ \mrule
  197&\token{shlo\_l\_32}&1&$\reg'_D = \sext{4}{(\reg_A \cdot 2^{\reg_B \bmod 32}) \bmod 2^{32}}$\\ \mrule
  198&\token{shlo\_r\_32}&1&$\reg'_D = \sext{4}{\floor{(\reg_A \bmod 2^{32}) \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  199&\token{shar\_r\_32}&1&$\reg'_D = \unsigned{\floor{\signedn{4}{\reg_A \bmod 2^{32}} \div 2^{\reg_B \bmod 32}}}$\\ \mrule

  200&\token{add\_64}&1&$\reg'_D = (\reg_A + \reg_B) \bmod 2^{64}$\\ \mrule
  201&\token{sub\_64}&1&$\reg'_D = (\reg_A + 2^{64} - \reg_B) \bmod 2^{64}$\\ \mrule
  202&\token{mul\_64}&1&$\reg'_D = (\reg_A \cdot \reg_B) \bmod 2^{64}$\\ \mrule
  203&\token{div\_u\_64}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when \reg_B = 0\\
    \floor{\reg_A \div \reg_B} &\otherwise
  \end{cases}$\\ \mrule
  204&\token{div\_s\_64}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when \reg_B = 0\\
    \reg_A &\when \signed{\reg_A} = -2^{63} \wedge \signed{\reg_B} = -1\\
    \unsigned{\rtz(\signed{\reg_A} \div \signed{\reg_B})} &\otherwise
  \end{cases}$\\ \mrule
  205&\token{rem\_u\_64}&1&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    \reg_A \bmod \reg_B &\otherwise
  \end{cases}$\\ \mrule
  206&\token{rem\_s\_64}&1&$\reg'_D = \begin{cases}
    0 &\when \signed{\reg_A} = -2^{63} \wedge \signed{\reg_B} = -1\\
    \unsigned{\smod(\signed{\reg_A}, \signed{\reg_B})} &\otherwise
  \end{cases}$\\ \mrule
  207&\token{shlo\_l\_64}&1&$\reg'_D = (\reg_A \cdot 2^{\reg_B \bmod 64}) \bmod 2^{64}$\\ \mrule
  208&\token{shlo\_r\_64}&1&$\reg'_D = \floor{\reg_A \div 2^{\reg_B \bmod 64}}$\\ \mrule
  209&\token{shar\_r\_64}&1&$\reg'_D = \unsigned{\floor{\signed{\reg_A} \div 2^{\reg_B \bmod 64}}}$\\ \mrule

  210&\token{and}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \wedge \bits{\reg_B}\sub{i}$\\ \mrule
  211&\token{xor}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \oplus \bits{\reg_B}\sub{i}$\\ \mrule
  212&\token{or}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \vee \bits{\reg_B}\sub{i}$\\ \mrule
  213&\token{mul\_upper\_s\_s}&1&$\reg'_D = \unsigned{\floor{(\signed{\reg_A} \cdot \signed{\reg_B}) \div 2^{64}}}$\\ \mrule
  214&\token{mul\_upper\_u\_u}&1&$\reg'_D = \floor{(\reg_A \cdot \reg_B) \div 2^{64}}$\\ \mrule
  215&\token{mul\_upper\_s\_u}&1&$\reg'_D = \unsigned{\floor{(\signed{\reg_A} \cdot \reg_B) \div 2^{64}}}$\\ \mrule
  216&\token{set\_lt\_u}&1&$\reg'_D = \reg_A < \reg_B$\\ \mrule
  217&\token{set\_lt\_s}&1&$\reg'_D = \signed{\reg_A} < \signed{\reg_B}$\\ \mrule
  218&\token{cmov\_iz}&1&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    \reg_D &\otherwise
  \end{cases}$\\ \mrule
  219&\token{cmov\_nz}&1&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B \ne 0\\
    \reg_D &\otherwise
  \end{cases}$\\ \mrule
  220&\token{rot\_l\_64}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_D)_{(i + \reg_B) \bmod 64} = \bitsfunc{8}(\reg_A)\sub{i}$\\ \mrule
  221&\token{rot\_l\_32}&1&$\reg'_D = \sext{4}{x}\ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)_{(i + \reg_B) \bmod 32} = \bitsfunc{4}(\reg_A)\sub{i}$\\ \mrule
  222&\token{rot\_r\_64}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_D)\sub{i} = \bitsfunc{8}(\reg_A)_{(i + \reg_B) \bmod 64}$\\ \mrule
  223&\token{rot\_r\_32}&1&$\reg'_D = \sext{4}{x}\ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)\sub{i} = \bitsfunc{4}(\reg_A)_{(i + \reg_B) \bmod 32}$\\ \mrule
  224&\token{and\_inv}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \wedge \lnot \bits{\reg_B}\sub{i}$\\ \mrule
  225&\token{or\_inv}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \vee \lnot \bits{\reg_B}\sub{i}$\\ \mrule
  226&\token{xnor}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \lnot ( \bits{\reg_A}\sub{i} \oplus \bits{\reg_B}\sub{i} )$\\ \mrule
  227&\token{max}&1&$\reg'_D = \unsigned{\max \tup{ \signed{\reg_A}, \signed{\reg_B} }}$\\ \mrule
  228&\token{max\_u}&1&$\reg'_D = \max \tup{ \reg_A, \reg_B }$\\ \mrule
  229&\token{min}&1&$\reg'_D = \unsigned{\min \tup{ \signed{\reg_A}, \signed{\reg_B} }}$\\ \mrule
  230&\token{min\_u}&1&$\reg'_D = \min \tup{ \reg_A, \reg_B }$\\
\bottomrule
\end{longtable}

请注意，两种有符号取模运算有其特立独行的定义：对绝对值取模，但结果取被除数的符号。形式化地：
\begin{equation}
  \smod\colon\abracegroup{
    \tuple{\Z, \Z} &\to \Z\\
    \tup{a, b} &\mapsto \begin{cases}
      a &\when b = 0\\
      \text{sgn}(a) \cdot (\len{a} \bmod \len{b}) &\otherwise \\
    \end{cases}
  }
\end{equation}

除法运算的结果总是向零取整。形式化地：
\begin{equation}
  \rtz\colon\abracegroup{
    \Z &\to \Z\\
    x &\mapsto \begin{cases}
      \ceil{x} &\when x < 0\\
      \floor{x} &\otherwise \\
    \end{cases}
  }
\end{equation}

\subsection{Host Call Definition}

我们定义扩展版的 \textsc{pvm} 调用 $\Psi_H$，它能够在出现宿主调用停机条件时推进内部的\emph{宿主调用}状态机：
\begin{align}
  &\Psi_H\colon \abracegroup{
    \tuple{\begin{aligned}
      &\blob, \pvmreg, \gas, \regs,\\&\ram, \contextmutator{X}, X
    \end{aligned}
    }
    &\to
    \tuple{\set{\panic, \oog, \halt} \cup \set{\fault} \times \pvmreg, \pvmreg, \signedgas, \regs, \ram, X}\\
    \tup{\mathbf{c}, \imath, \gascounter, \registers, \mem, f, \mathbf{x}} &\mapsto \begin{cases}
      \multicolumn{2}{l}{\text{let }(\varepsilon', \imath', \gascounter', \registers', \mem') = \Psi(\mathbf{c}, \imath, \gascounter, \registers, \mem):} \\[8pt]
      \tup{\varepsilon', \imath', \gascounter', \registers', \mem', \mathbf{x}} &\when \varepsilon' \in \set{ \halt, \panic, \oog } \cup \set{\fault} \times \pvmreg \\[4pt]
      \begin{aligned}
        &\Psi_H(\mathbf{c}, \imath'', \gascounter'', \registers'', \mem'', f, \mathbf{x}'')\\[2pt]
        &\quad \where \imath'' = \imath' + 1 + \Fskip(\imath')
      \end{aligned}
       &\when \bigwedge\abracegroup[\;]{
        &\varepsilon' = \host \times h\\[2pt]
        &\tup{\continue, \gascounter'', \registers'', \mem'', \mathbf{x}''} = f(h, \gascounter', \registers', \mem', \mathbf{x})
      }\\[8pt]
      \tup{\varepsilon'', \imath', \gascounter'', \registers'', \mem'', \mathbf{x}''} &\when  \bigwedge\abracegroup[\;]{
        &\varepsilon' = \host \times h\\[2pt]
        &\tup{\varepsilon'', \gascounter'', \registers'', \mem'', \mathbf{x}''} = f(h, \gascounter', \registers', \mem', \mathbf{x})\\[2pt]
        &\varepsilon'' \in \set{\panic, \halt, \oog}
      }\\[8pt]
    \end{cases} \\
    }\!\!\!\!\!\!\!\!\\
    &\contextmutator{X} \equiv \tuple{\N, \gas, \regs, \ram, X} \to \tuple{\set{\continue, \halt, \panic, \oog}, \gas, \regs, \ram, X}
\end{align}

与 $\Phi$ 一样，在退出时，指令计数器指向\emph{导致退出的那条指令}，机器状态为该指令之前的状态。若再次以该指令计数器与代码调用机器，则会在正确（先前）的机器状态上再次执行导致退出的同一条指令。

使用 $\Phi_H$ 时，宿主调用（即 \token{ecalli} 指令）事实上在内部通过所提供的状态变更函数处理，从而避免结果为宿主调用故障的可能。注意：当宿主调用状态转换成功时，我们必须与该指令的新后验状态一起，显式给出新的指令计数器值 $\imath''$。

\subsection{Standard Program Initialization}\label{sec:standardprograminit}
主文档中 \textsc{pvm} 被使用的四个场景中，各自运行的软件程序具有非常典型的初始化模式，这是编译器与链接器产物的共性。具体来说，\textsc{ram} 包含了程序特有的只读数据段、读写（堆）数据段以及栈。与此配套、并且非常符合我们的使用场景的是：还有一个额外只读段用于传递与调用相关的数据（即参数）。因此有必要用一个统一的初始化函数来恰当地定义它们。这些段被量化为\emph{主要区段}（major zones），并且在各段之间总会留出一个未分配的主要区段，以减少意外越界。各段被填充零，直至对齐到最近的 \textsc{pvm} 内存页边界。

于是我们定义标准的程序代码格式 $\mathbf{p}$，它不仅包含指令与跳转表（此前用 $\mathbf{c}$ 表示），还包含程序启动时 \textsc{ram} 的状态信息。给定程序 blob $\mathbf{p}$ 与参数数据 $\mathbf{a}$，我们可以通过标准初始化函数 $Y(\mathbf{p}, \mathbf{a})$ 解码得到程序代码 $\mathbf{c}$、寄存器 $\registers$ 与 \textsc{ram} $\mem$：
\begin{equation}
Y\colon\abracegroup{
  \tuple{\blob, \blob[:\Cpvminitinputsize]} &\to \tuple{\blob, \regs, \ram}? \\
  \tup{\mathbf{p}, \mathbf{a}} &\mapsto \begin{cases}
    \tup{\mathbf{c}, \registers, \mem} &\when \exists! \tup{\mathbf{c}, \mathbf{o}, \mathbf{w}, z, s} \text{ which satisfy equation \ref{eq:conditions}}\\
    \none &\otherwise
  \end{cases}
}
\end{equation}
With conditions:
\begin{align}\label{eq:conditions}
  &\using \mathcal{E}_3(\len{\mathbf{o}}) \concat \mathcal{E}_3(\len{\mathbf{w}}) \concat \mathcal{E}_2(z) \concat \mathcal{E}_3(s) \concat \mathbf{o} \concat \mathbf{w} \concat \mathcal{E}_4(\len{\mathbf{c}}) \concat \mathbf{c} = \mathbf{p}\\
  &\Cpvminitzonesize = 2^{16}\ ,\quad\Cpvminitinputsize = 2^{24}\\
  &\using \rnp{x \in \N} \equiv \Cpvmpagesize\ceil{ \frac{x}{\Cpvmpagesize} }\quad,\qquad\rnq{x \in \N} \equiv \Cpvminitzonesize\ceil{ \frac{x}{\Cpvminitzonesize} }\\
  &5\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \rnq{\len{\mathbf{w}} + z\Cpvmpagesize} + \rnq{s} + \Cpvminitinputsize \leq 2^{32}
\end{align}
因此，若无法用唯一值满足上述条件，则结果为 $\none$；否则结果为一个元组，其中包含如上所述的 $\mathbf{c}$，以及满足下述性质的 $\mem$ 与 $\registers$：
\begin{equation}\label{eq:memlayout}
  \forall i \in \Nbits{32} : ((\mem_\ram¬value)\sub{i}, (\mem_\ram¬access)_{\floor{\nicefrac{i}{\Cpvmpagesize}}}) = \bracegroup{\begin{alignedat}{5}
    &\tup{\is{\ram¬value}{\mathbf{o}_{i - \Cpvminitzonesize}},\,\is{\ram¬access}{R}} &&\ \when
        \Cpvminitzonesize
            &\ \leq i < \ &&
                \Cpvminitzonesize + \len{\mathbf{o}}\\
    &\tup{0, R} &&\ \when
        \Cpvminitzonesize + \len{\mathbf{o}}
            &\ \leq i < \ &&
                \Cpvminitzonesize + \rnp{\len{\mathbf{o}}} \\
    &(\mathbf{w}_{i - (2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}})}, W) &&\ \when
        2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}}
            &\ \leq i < \ &&
                2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \len{\mathbf{w}}\\
    &\tup{0, W} &&\ \when
        2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \len{\mathbf{w}}
            &\ \leq i < \ &&
                2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \rnp{\len{\mathbf{w}}} + z\Cpvmpagesize\\
    &\tup{0, W} &&\ \when
        2^{32} - 2\Cpvminitzonesize - \Cpvminitinputsize - \rnp{s}
            &\ \leq i < \ &&
                2^{32} - 2\Cpvminitzonesize - \Cpvminitinputsize\\
    &(\mathbf{a}_{i - (2^{32} - \Cpvminitzonesize - \Cpvminitinputsize)}, R) &&\ \when
        2^{32} - \Cpvminitzonesize - \Cpvminitinputsize
            &\ \leq i < \ &&
                2^{32} - \Cpvminitzonesize - \Cpvminitinputsize + \len{\mathbf{a}}\\
    &\tup{0, R} &&\ \when
        2^{32} - \Cpvminitzonesize - \Cpvminitinputsize + \len{\mathbf{a}}
            &\ \leq i < \ &&
                2^{32} - \Cpvminitzonesize - \Cpvminitinputsize + \rnp{\len{\mathbf{a}}}\\
    &\tup{0, \none} &&\otherwise&&&
  \end{alignedat}}\\
\end{equation}
\begin{equation}\label{eq:registers}
  \forall i \in \Nmax{13} : \registers\sub{i} = \begin{cases}
      2^{32} - 2^{16} &\when i = 0\\
      2^{32} - 2\Cpvminitzonesize - \Cpvminitinputsize &\when i = 1\\
      2^{32} - \Cpvminitzonesize - \Cpvminitinputsize &\when i = 7\\
      \len{\mathbf{a}}&\when i = 8\\
      0 &\otherwise
    \end{cases}
\end{equation}

\subsection{Argument Invocation Definition}

\textsc{pvm} 被使用的四个场景都希望能够传入参数数据并接收返回数据。于是我们定义通用的 \textsc{pvm} 程序参数调用函数 $\Psi_M$：
\begin{equation}
  \Psi_M\colon \abracegroup{
    \tuple{
      \blob, \pvmreg, \gas, \blob[:\Cpvminitinputsize], \contextmutator{X}, X
    } &\to \tuple{\gas, \blob \cup \set{\panic, \oog}, X}\\
    \tup{\mathbf{p}, \imath, \gascounter, \mathbf{a}, f, \mathbf{x}} &\mapsto \begin{cases}
      \tup{0, \panic, \mathbf{x}} &\when Y(\mathbf{p}, \mathbf{a}) = \none\\
      R(\gascounter, \Psi_H(\mathbf{c}, \imath, \gascounter, \registers, \mem, f, \mathbf{x})) &\when Y(\mathbf{p}, \mathbf{a}) = \tup{\mathbf{c}, \registers, \mem}\\
      \multicolumn{2}{l}{
        \quad \where R \colon \tup{\gascounter, \tup{\begin{alignedat}{5}
          &\varepsilon,\, &&\imath',\, &&\gascounter',\\
          &\registers',\, &&\mem',\, &&\mathbf{x}'
        \end{alignedat}
        }} \mapsto \begin{cases}
          \tup{u, \oog, \mathbf{x}'} &\when \varepsilon = \oog \\
          \tup{u, \memory'_{\registers'_{7}\dots+\registers'_{8}}, \mathbf{x}'} &\when \varepsilon = \halt \wedge \Nrange{\registers'_{7}}{\registers'_{8}} \subseteq \readable{\mem'} \\
          \tup{u, \sq{}, \mathbf{x}'} &\when \varepsilon = \halt \wedge \Nrange{\registers'_{7}}{\registers'_{8}} \not\subseteq \readable{\mem'} \\
          \tup{u, \panic, \mathbf{x}'} &\otherwise \\
          \multicolumn{2}{l}{\quad \where u = \gascounter - \max(\gascounter', 0)}
        \end{cases}
      }\!\!\!\!\!\!\!\!
    \end{cases}
  }
\end{equation}

注意：返回元组的第一项是本次操作消耗的 gas 数量，但永不超过为该操作提供的 gas 数量。
