\section{序列化编解码器}\label{sec:serialization}

\subsection{通用术语}

我们的编解码函数 $\mathcal{E}$ 用于将某个术语序列化为一串八位字节（octets）。我们将反序列化函数 $\fndecode$ 定义为 $\mathcal{E}$ 的逆，能够把字节序列还原为原始值。该编解码器被设计为：任意给定的字节序列恰好对应唯一一个值；若在某些情形下不希望满足该性质，则使用专用的编解码函数。

\subsubsection{平凡编码}
我们将 $\none$ 的序列化定义为空序列：
\begin{equation}
  \encode{\none} \equiv \sq{}
\end{equation}

我们将一个八位字节序列（octet sequence）的序列化定义为其自身：
\begin{equation}
  \encode{x \in \blob} \equiv x
\end{equation}

我们将匿名元组的序列化定义为其各个已编码元素的串联：
\begin{equation}
  \encode{\tup{a, b, \dots}} \equiv \encode{a} \concat \encode{b} \concat \dots
\end{equation}

向序列化函数传入多个参数等价于将这些参数组成一个元组后再进行编码。形式化地：
\begin{align}
  \encode{a, b, \dots} &\equiv \encode{\tup{a, b, \dots}}
\end{align}

我们定义通用的自然数序列化函数，可编码不超过 $2^{64}$ 的自然数，如下：
\begin{equation}
  \fnencode\colon\abracegroup{
    \Nbits{64} &\to \blob[1:9] \\
    x &\mapsto \begin{cases}
     \sq{0} &\when x = 0 \\
      \sq{2^8-2^{8-l} + \ffrac{x}{2^{8l}}} \concat \encode[l]{x \bmod 2^{8l}} &\when \exists l \in \N_8 : 2^{7l} \le x < 2^{7(l+1)} \\
     \sq{2^8-1} \concat \encode[8]{x} &\otherwhen x < 2^{64} \\
    \end{cases}
  }
\end{equation}

\subsubsection{序列编码}
对于任意 $T$（其本身是 $\fnencode$ 定义域的子集），我们定义序列的序列化函数 $\encode{\sequence{T}}$：做法是依次将序列中每个元素的编码结果串联起来：
\begin{equation}
  \encode{[\mathbf{i}_0, \mathbf{i}_1, ...]} \equiv \encode{\mathbf{i}_0} \concat \encode{\mathbf{i}_1} \concat \dots
\end{equation}

因此，定长八位字节序列（例如哈希 $\hash$ 及其变体）的序列化就是恒等映射。

\subsubsection{判别符编码}
当需要对异构集合（例如不同类型元组的并集、或不同长度序列的并集）进行编码时，为了在解码时判明被编码项的具体类型，必须引入“判别符”（discriminator）。判别符以自然数形式编码，并紧挨着被编码项之前写入。

We generally use a \emph{length discriminator} when serializing sequence terms which have variable length (\eg general blobs $\blob$ or unbound numeric sequences $\sequence{\N}$) (though this is omitted in the case of fixed-length terms such as hashes $\hash$).\footnote{Note that since specific values may belong to both sets which would need a discriminator and those that would not then we are sadly unable to introduce a function capable of serializing corresponding to the \emph{term}'s limitation. A more sophisticated formalism than basic set-theory would be needed, capable of taking into account not simply the value but the term from which or to which it belongs in order to do this succinctly.} In this case, we simply prefix the term its length prior to encoding. Thus, for some term $y \in \tup{x \in \blob, \dots}$, we would generally define its serialized form to be $\encode{\len{x}}\concat\encode{x}\concat\dots$. To avoid repetition of the term in such cases, we define the notation $\var{x}$ to mean that the term of value $x$ is variable in size and requires a length discriminator. Formally:
\begin{equation}
  \var{x} \equiv \tup{\len{x}, x}\text{ thus }\encode{\var{x}} \equiv \encode{\len{x}}\concat\encode{x}
\end{equation}

We also define a convenient discriminator operator $\maybe{x}$ specifically for terms defined by some serializable set in union with $\none$ (generally denoted for some set $S$ as $\optional{S}$):
\begin{align}
  \maybe{x} \equiv \begin{cases}
    0 &\when x = \none \\
    \tup{1, x} &\otherwise
  \end{cases}
\end{align}

\subsubsection{比特序列编码}
比特序列 $b \in \bitstring$ 是一种特殊情况：若逐比特按整字节编码会非常低效。因此我们按从最低有效位到最高有效位的顺序将比特打包为八位字节，并排布为字节流。若该序列为变长，则如常规情形一样在前缀写入长度。
\begin{align}
  \encode{b \in \bitstring} &\equiv \begin{cases}
    \sq{} &\when b = \sq{} \\
    \sq{
      \sum\limits_{i=0}^{i < \min(8, \len{b})}
      b\sub{i} \cdot 2^i
    } \concat \encode{b\interval{8}{}} &\otherwise\\
  \end{cases}
\end{align}

\subsubsection{字典编码}
通常，字典会直接放入 Merkle Trie（详见附录 \ref{sec:merklization}）。但对于较小的字典，也可以按键（key）排序后，以键值对序列的形式进行编码。形式化地：
\begin{equation}
  \forall K, V: \encode{d \in \dictionary{K}{V}} \equiv
    \encode{
      \var{\sq{
        \orderby{k}{
          \build{
            \tup{\encode{k}, \encode{d\subb{k}}}
          }{
            k \in \keys{d}
          }
        }
      }}
    }
\end{equation}

\subsubsection{集合编码}
对于尚未在上文定义专门编码方式的集合类型，我们将其序列化定义为：按正确次序依次序列化其元素并串联。形式化地：
\begin{equation}
  \encode{\set{a, b, c, \dots}} \equiv \encode{a} \concat \encode{b} \concat \encode{c} \concat \dots \where a < b < c < \dots
\end{equation}

\subsubsection{定长整数编码}
We first define the trivial natural number serialization functions which are subscripted by the number of octets of the final sequence. Values are encoded in a regular little-endian fashion. This is utilized for almost all integer encoding across the protocol. Formally:
\begin{equation}
  \fnencode[l \in \N]\colon\abracegroup{
    \Nbits{8l} &\to \blob[l] \\
    x &\mapsto \begin{cases}
      \sq{} &\when l = 0 \\
      \sq{x \bmod 256} \concat \encode[l - 1]{\floor{\frac{x}{256}}} &\otherwise
    \end{cases}
  }
\end{equation}

对于非自然数参数，$\fnencode[l \in \N]$ 的规则与 $\fnencode$ 相同，唯一区别是递归出现的子元素统一使用 $\fnencode[l]$ 而非 $\fnencode$。因此：
\begin{align}
  \encode[l \in \N]{a, b, \dots} &\equiv \encode[l]{\tup{a, b, \dots}}\\
  \encode[l \in \N]{\tup{a, b, \dots}} &\equiv \encode[l]{a} \concat \encode[l]{b} \concat \dots\\
  \encode[l \in \N]{\sq{\mathbf{i}_0, \mathbf{i}_1, \dots}} &\equiv \encode[l]{\mathbf{i}_0} \concat \encode[l]{\mathbf{i}_1} \concat \dots
\end{align}

以此类推。

\subsection{区块序列化}

区块 $\block$ 的序列化按照其各组成元素的常规顺序打包为一个元组（参见式 \ref{eq:block}、\ref{eq:extrinsic} 与 \ref{eq:header}）。对于区块头，我们同时给出常规序列化与“未签名序列化” $\fnencodeunsignedheader$。形式化地：

\newcommand*{\encoderesult}[1]{O\left(#1\right)}
\newcommand*{\encodeimportref}[1]{I\left(#1\right)}
\newcommand*{\encodeimportrefs}[1]{I^\#\left(#1\right)}
\begin{align}
  \encode{\block} &= \encode{
    \header,
    \encodetickets{\xttickets},
    \encodepreimages{\xtpreimages},
    \encodeguarantees{\xtguarantees},
    \encodeassurances{\xtassurances},
    \encodedisputes{\xtdisputes}
  }
  \\
  \encodetickets{\xttickets} &= \encode{\var{\xttickets}} 
  \\
  \encodepreimages{\xtpreimages} &= \encode{
    \var{\sq{\build{
      \tup{\encode[4]{\xp¬serviceindex}, \var{\xp¬data}}
    }{
      \tup{\xp¬serviceindex, \xp¬data} \orderedin \xtpreimages}
    }}}
  \\
  \encodeguarantees{\xtguarantees} &= \encode{
    \var{\sq{\build{
      \tup{\xg¬workreport, \encode[4]{\xg¬timeslot}, \var{
        \sq{\build{
          \tup{\encode[2]{v}, s}
        }{
          \tup{v, s} \orderedin \xg¬credential
        }}
      }}
    }{
      \tup{\xg¬workreport, \xg¬timeslot, \xg¬credential} \orderedin \xtguarantees}
    }}}
  \\
  \encodeassurances{\xtassurances} &= \encode{
    \var{\sq{\build{
      \tup{\xa¬anchor, \xa¬availabilities, \encode[2]{\xa¬assurer}, \xa¬signature}
    }{
      \tup{\xa¬anchor, \xa¬availabilities, \xa¬assurer, \xa¬signature} \orderedin \xtassurances}
    }}}
  \\
  \encodedisputes{\tup{\mathbf{v}, \mathbf{c}, \mathbf{f}}} &= \encode{
    \var{\sq{\build{
      \tup{\xv¬reporthash, \encode[4]{\xv¬epochindex},
        \sq{\build{
          \tup{\xvj¬validity, \encode[2]{\xvj¬judgeindex}, \xvj¬signature}
        }{
          \tup{\xvj¬validity, \xvj¬judgeindex, \xvj¬signature} \orderedin \xv¬judgments
        }}
      }
    }{
      \tup{\xv¬reporthash, \xv¬epochindex, \xv¬judgments} \orderedin \mathbf{v}
    }}},
    \var{\mathbf{c}},
    \var{\mathbf{f}}
  }
  \\
  \encode{\header} &= \encode{
    \encodeunsignedheader{\header},
    \H_\¬sealsig
  }
  \\
  \encodeunsignedheader{\header} &= \encode{
    \H_\¬parent,
    \H_\¬priorstateroot,
    \H_\¬extrinsichash,
    \encode[4]{\H_\¬timeslot},
    \maybe{\H_\¬epochmark},
    \maybe{\H_\¬winnersmark},
    \encode[2]{\H_\¬authorindex},
    \H_\¬vrfsig,
    \var{\H_\¬offendersmark}
  }
  \\
  \encode{\wcX \in \workcontext} &\equiv \encode{
    \wcX_\wc¬anchorhash,
    \wcX_\wc¬anchorpoststate,
    \wcX_\wc¬anchoraccoutlog,
    \wcX_\wc¬lookupanchorhash,
    \encode[4]{\wcX_\wc¬lookupanchortime},
    \var{\wcX_\wc¬prerequisites}
  }
  \\
  \encode{\asX \in \avspec} &\equiv \encode{
    \asX_\as¬packagehash,
    \encode[4]{\asX_\as¬bundlelen},
    \asX_\as¬erasureroot,
    \asX_\as¬segroot,
    \encode[2]{\asX_\as¬segcount}
  }
  \\
  \encode{\wdX \in \workdigest} &\equiv \encode{
    \encode[4]{\wdX_\wd¬serviceindex},
    \wdX_\wd¬codehash,
    \wdX_\wd¬payloadhash,
    \encode[8]{\wdX_\wd¬gaslimit},
    \encoderesult{\wdX_\wd¬result},
    % These are variable length, since we never access them individually, digests
    % are never accessed directly by the PVM and space is at a premium here.
    \wdX_\wd¬gasused,
    \wdX_\wd¬importcount,
    \wdX_\wd¬xtcount,
    \wdX_\wd¬xtsize,
    \wdX_\wd¬exportcount
  }
  \\
  \encode{\wrX \in \workreport} &\equiv \encode{
    \wrX_\wr¬avspec,
    \wrX_\wr¬context,
    \wrX_\wr¬core,
    \wrX_\wr¬authorizer,
    \wrX_\wr¬authgasused,
    \var{\wrX_\wr¬authtrace},
    \var{\wrX_\wr¬srlookup},
    \var{\wrX_\wr¬digests}
  }
  \\
  \encode{\wpX \in \workpackage} &\equiv \encode{
    \encode[4]{\wpX_\wp¬authcodehost},
    \wpX_\wp¬authcodehash,
    \wpX_\wp¬context,
    \var{\wpX_\wp¬authtoken},
    \var{\wpX_\wp¬authconfig},
    \var{\wpX_\wp¬workitems}
  }
  \\
  \encode{\wiX \in \workitem} &\equiv \encode{
    \encode[4]{\wiX_\wi¬serviceindex},
    \wiX_\wi¬codehash,
    \encode[8]{\wiX_\wi¬refgaslimit},
    \encode[8]{\wiX_\wi¬accgaslimit},
    \encode[2]{\wiX_\wi¬exportcount},
    \var{\wiX_\wi¬payload},
    \var{\encodeimportrefs{\wiX_\wi¬importsegments}},
    \var{\sq{\build{
      \tup{h, \encode[4]{i}}
    }{
      \tup{h, i} \orderedin \wiX_\wi¬extrinsics
    }}}
  }
  \\
  \encode{\stX \in \safroleticket} &\equiv \encode{
    \stX_\st¬id,
    \stX_\st¬entryindex
  }
  \\
  \encode[X]{\dxX \in \defxfer} &\equiv \encode{
    \encode[4]{\dxX_\dx¬source},
    \encode[4]{\dxX_\dx¬dest},
    \encode[8]{\dxX_\dx¬amount},
    \dxX_\dx¬memo,
    \encode[8]{\dxX_\dx¬gas}
  }
  \\
  \encode[U]{\otX \in \operandtuple} &\equiv \encode{
    \otX_\ot¬packagehash,
    \otX_\ot¬segroot,
    \otX_\ot¬authorizer,
    \otX_\ot¬payloadhash,
    \otX_\ot¬gaslimit,
    \encoderesult{\otX_\ot¬result},
    \var{\otX_\ot¬authtrace}
  }
  \\
  \encode{\aiX \in \accinput} &\equiv \begin{cases}
      \encode{0, \encode[U]{o}} &\when \aiX \in \operandtuple \\
      \encode{1, \encode[X]{o}} &\when \aiX \in \defxfer \\
  \end{cases}
  \\
  \encoderesult{o \in \workerror \cup \blob} &\equiv \begin{cases}
    \tup{0, \var{o}} &\when o \in \blob \\
    1 &\when o = \infty \\
    2 &\when o = \panic \\
    3 &\when o = \badexports \\
    4 &\when o = \oversize \\
    5 &\when o = \token{BAD} \\
    6 &\when o = \token{BIG}
    \\
  \end{cases}
  \\
  \encodeimportref{\tup{
    h \in \hash \cup \hash^\boxplus,
    i \in \Nbits{15}
  }} &\equiv \begin{cases}
    \tup{h, \encode[2]{i}} &\when h \in \hash\\
    \tup{r, \encode[2]{i + 2^{15}}} &\when \exists r \in \hash, h = r^\boxplus\\
  \end{cases}
\end{align}

注意：上文使用了 $O$ 来简洁地编码工作项的结果；同时对 $\xtguarantees$ 与 $\xtpreimages$ 做了轻微改写，这是因为它们的内部元组分别包含变长序列项 $a$ 与 $p$，需要带上长度判别符。
